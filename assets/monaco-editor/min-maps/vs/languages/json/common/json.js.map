{"version":3,"sources":["vs/languages/json/common/fake","vs/languages/json/common/json.js","vs/languages/json/common/file:/C:/Alex/src/vscode/src/vs/languages/json/common/features/jsonTokenTypes.ts","vs/languages/json/common/file:/C:/Alex/src/vscode/src/vs/base/common/json.ts","vs/languages/json/common/file:/C:/Alex/src/vscode/src/vs/languages/json/common/features/tokenization.ts","vs/languages/json/common/file:/C:/Alex/src/vscode/src/vs/languages/json/common/json.ts"],"names":["__m","__M","deps","result","i","len","length","define","require","exports","TOKEN_DELIM_OBJECT","TOKEN_DELIM_ARRAY","TOKEN_DELIM_COLON","TOKEN_DELIM_COMMA","TOKEN_VALUE_BOOLEAN","TOKEN_VALUE_NULL","TOKEN_VALUE_STRING","TOKEN_VALUE_NUMBER","TOKEN_PROPERTY_NAME","TOKEN_COMMENT_BLOCK","TOKEN_COMMENT_LINE","nls","data","create","nls_1","createScanner","text","ignoreTrivia","scanHexDigits","count","exact","digits","value","ch","charCodeAt","pos","CharacterCodes","_0","_9","A","F","a","f","setPosition","newPosition","tokenOffset","token","SyntaxKind","Unknown","scanError","ScanError","None","scanNumber","start","isDigit","dot","UnexpectedEndOfNumber","substring","end","E","e","plus","minus","scanString","UnexpectedEndOfString","doubleQuote","backslash","isLineBreak","slash","b","n","r","t","u","ch_1","String","fromCharCode","InvalidUnicode","InvalidEscapeCharacter","scanNext","EOF","code","isWhiteSpace","Trivia","carriageReturn","lineFeed","LineBreakTrivia","openBrace","OpenBraceToken","closeBrace","CloseBraceToken","openBracket","OpenBracketToken","closeBracket","CloseBracketToken","colon","ColonToken","comma","CommaToken","StringLiteral","LineCommentTrivia","asterisk","safeLength","commentClosed","UnexpectedEndOfComment","BlockCommentTrivia","_1","_2","_3","_4","_5","_6","_7","_8","NumericLiteral","isUnknownContentCharacter","TrueKeyword","FalseKeyword","NullKeyword","scanNextNonTrivia","getPosition","scan","getToken","getTokenValue","getTokenOffset","getTokenLength","getTokenError","space","tab","verticalTab","formFeed","nonBreakingSpace","ogham","enQuad","zeroWidthSpace","narrowNoBreakSpace","mathematicalSpace","ideographicSpace","byteOrderMark","lineSeparator","paragraphSeparator","stripComments","replaceCh","kind","_scanner","parts","offset","push","replace","join","getParseErrorMessage","errorCode","ParseErrorCode","InvalidSymbol","localize","InvalidNumberFormat","PropertyNameExpected","ValueExpected","ColonExpected","CommaExpected","CloseBraceExpected","CloseBracketExpected","EndOfFileExpected","getLiteralNodeType","getLocation","position","setPreviousNode","type","previousNodeInst","columnOffset","previousNode","segments","earlyReturnException","Object","isAtPropertyKey","visit","onObjectBegin","onObjectProperty","name","onObjectEnd","pop","onArrayBegin","onArrayEnd","onLiteralValue","onSeparator","sep","last","path","matches","pattern","k","parse","errors","options","onValue","Array","isArray","currentParent","currentProperty","previousParents","visitor","object","array","onError","error","parseTree","ensurePropertyComplete","endOffset","parent","valueNode","children","findNodeAtLocation","root","node","_i","path_1","segment","found","_a","_b","propertyNode","index","getNodeValue","map","obj","prop","toNoArgVisit","visitFunction","toOneArgVisit","arg","disallowComments","handleError","skipUntilAfter","skipUntil","indexOf","parseString","isValue","parseLiteral","JSON","parseProperty","parseValue","parseObject","needsComma","parseArray","json","jsonTokenTypes","createTokenizationSupport","mode","supportComments","shouldGenerateEmbeddedModels","getInitialState","JSONState","tokenize","line","state","offsetDelta","stopAtOffset","comments","numberOfInsertedCharacters","adjustOffset","ret","scanner","lastWasColon","tokens","actualStopOffset","endState","clone","modeTransitions","startIndex","Error","substr","getMode","getStateData","this","_mode","_state","prototype","equals","other","stream","setStateData","__extends","d","__","constructor","p","hasOwnProperty","__decorate","decorators","target","key","desc","c","arguments","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","modes","Platform","tokenization","abstractMode_1","threadService_1","thread_1","jsonContributionRegistry_1","instantiation_1","languageConfigurationRegistry_1","async_1","JSONMode","_super","descriptor","instantiationService","threadService","_this","call","id","_modeWorkerManager","ModeWorkerManager","_threadService","tokenizationSupport","LanguageConfigurationRegistry","register","getId","LANG_CONFIG","HoverProviderRegistry","provideHover","model","wireCancellationToken","_provideHover","uri","inplaceReplaceSupport","configSupport","DocumentSymbolProviderRegistry","provideDocumentSymbols","_provideDocumentSymbols","DocumentFormattingEditProviderRegistry","provideDocumentFormattingEdits","_provideDocumentFormattingEdits","DocumentRangeFormattingEditProviderRegistry","provideDocumentRangeFormattingEdits","range","_provideDocumentRangeFormattingEdits","SuggestRegistry","triggerCharacters","shouldAutotriggerSuggest","provideCompletionItems","_provideCompletionItems","creationDone","isInMainThread","_pickAWorkerToValidate","_configureWorkerSchemas","getSchemaConfiguration","contributionRegistry","Registry","as","Extensions","JSONContribution","addRegistryChangedListener","_worker","runner","worker","getSchemaContributions","configure","_configureWorkers","w","_doConfigure","setSchemaContributions","enableValidator","navigateValueSet","resource","up","format","wordPattern","createWordRegExp","lineComment","blockComment","brackets","autoClosingPairs","open","close","notIn","$_configureWorkers","AllWorkersAttr","$_configureWorkerSchemas","$_pickAWorkerToValidate","OneWorkerAttr","ThreadAffinity","Group1","$navigateValueSet","$_provideCompletionItems","$_provideHover","$_provideDocumentSymbols","$_provideDocumentFormattingEdits","$_provideDocumentRangeFormattingEdits","IInstantiationService","IThreadService","AbstractMode"],"mappings":";;;;;;CAAA,WACA,GAAAA,IAAA,UAAA,UAAA,mDAAA,6BAAA,sBAAA,iDAAA,uBAAA,SAAA,gCAAA,uCAAA,uBAAA,sCAAA,0CAAA,mCAAA,0DAAA,iDAAA,uDAAA,0BACAC,EAAA,SAAAC,GAEA,IAAA,GADAC,MACAC,EAAA,EAAAC,EAAAH,EAAAI,OAAAD,EAAAD,EAAAA,IACAD,EAAAC,GAAAJ,EAAAE,EAAAE,GAEA,OAAAD,GCSAI,QAAOP,EAAI,GAAIC,GAAK,EAAE,IAAK,SAAUO,EAASC,GCZ9C,YAEaA,GAAAC,mBAAqB,2BACrBD,EAAAE,kBAAoB,yBACpBF,EAAAG,kBAAoB,yBACpBH,EAAAI,kBAAoB,yBACpBJ,EAAAK,oBAAqB,sCACrBL,EAAAM,iBAAkB,6CAClBN,EAAAO,mBAAqB,2CACrBP,EAAAQ,mBAAqB,+CACrBR,EAAAS,oBAAsB,kCACtBT,EAAAU,oBAAsB,qBACtBV,EAAAW,mBAAqB,sBFhBlCb,OAAAP,EAAA,GAAAC,GAAA,EAAA,IAAA,SAAAoB,EAAAC,GAAA,MAAAD,GAAAE,OAAA,sBAAAD,KCoCAf,OAAOP,EAAI,GAAIC,GAAK,EAAE,EAAE,IAAK,SAAUO,EAASC,EAASe,GEhCzD,YA0EA,SAAAC,GAA8BC,EAAaC,GAS1C,QAAAC,GAAuBC,EAAeC,GAGrC,IAFA,GAAIC,GAAS,EACTC,EAAQ,EACIH,EAATE,IAAmBD,GAAO,CAChC,GAAIG,GAAKP,EAAKQ,WAAWC,EACzB,IAAIF,GAAMG,EAAeC,IAAMJ,GAAMG,EAAeE,GACnDN,EAAgB,GAARA,EAAaC,EAAKG,EAAeC,OAErC,IAAIJ,GAAMG,EAAeG,GAAKN,GAAMG,EAAeI,EACvDR,EAAgB,GAARA,EAAaC,EAAKG,EAAeG,EAAI,OAEzC,CAAA,KAAIN,GAAMG,EAAeK,GAAKR,GAAMG,EAAeM,GAIvD,KAHAV,GAAgB,GAARA,EAAaC,EAAKG,EAAeK,EAAI,GAK9CN,IACAJ,IAKD,MAHaF,GAATE,IACHC,EAAQ,IAEFA,EAGR,QAAAW,GAAqBC,GACpBT,EAAMS,EACNZ,EAAQ,GACRa,EAAc,EACdC,EAAQC,EAAWC,QACnBC,EAAYC,EAAUC,KAGvB,QAAAC,KACC,GAAIC,GAAQlB,CACZ,IAAIT,EAAKQ,WAAWC,KAASC,EAAeC,GAC3CF,QAGA,KADAA,IACOA,EAAMT,EAAKpB,QAAUgD,EAAQ5B,EAAKQ,WAAWC,KACnDA,GAGF,IAAIA,EAAMT,EAAKpB,QAAUoB,EAAKQ,WAAWC,KAASC,EAAemB,IAAK,CAErE,GADApB,MACIA,EAAMT,EAAKpB,QAAUgD,EAAQ5B,EAAKQ,WAAWC,KAOhD,MADAc,GAAYC,EAAUM,sBACf9B,EAAK+B,UAAUJ,EAAOlB,EAL7B,KADAA,IACOA,EAAMT,EAAKpB,QAAUgD,EAAQ5B,EAAKQ,WAAWC,KACnDA,IAOH,GAAIuB,GAAMvB,CACV,IAAIA,EAAMT,EAAKpB,SAAWoB,EAAKQ,WAAWC,KAASC,EAAeuB,GAAKjC,EAAKQ,WAAWC,KAASC,EAAewB,GAK9G,GAJAzB,KACIA,EAAMT,EAAKpB,QAAUoB,EAAKQ,WAAWC,KAASC,EAAeyB,MAAQnC,EAAKQ,WAAWC,KAASC,EAAe0B,QAChH3B,IAEGA,EAAMT,EAAKpB,QAAUgD,EAAQ5B,EAAKQ,WAAWC,IAAO,CAEvD,IADAA,IACOA,EAAMT,EAAKpB,QAAUgD,EAAQ5B,EAAKQ,WAAWC,KACnDA,GAEDuB,GAAMvB,MAENc,GAAYC,EAAUM,qBAGxB,OAAO9B,GAAK+B,UAAUJ,EAAOK,GAG9B,QAAAK,KAKC,IAHA,GAAI5D,GAAS,GACZkD,EAAQlB,IAEI,CACZ,GAAIA,GAAO9B,EAAK,CACfF,GAAUuB,EAAK+B,UAAUJ,EAAOlB,GAChCc,EAAYC,EAAUc,qBACtB,OAED,GAAI/B,GAAKP,EAAKQ,WAAWC,EACzB,IAAIF,IAAOG,EAAe6B,YAAa,CACtC9D,GAAUuB,EAAK+B,UAAUJ,EAAOlB,GAChCA,GACA,OAED,GAAIF,IAAOG,EAAe8B,UAA1B,CA+CA,GAAIC,EAAYlC,GAAK,CACpB9B,GAAUuB,EAAK+B,UAAUJ,EAAOlB,GAChCc,EAAYC,EAAUc,qBACtB,OAED7B,QApDA,CAGC,GAFAhC,GAAUuB,EAAK+B,UAAUJ,EAAOlB,GAChCA,IACIA,GAAO9B,EAAK,CACf4C,EAAYC,EAAUc,qBACtB,OAGD,OADA/B,EAAKP,EAAKQ,WAAWC,MAEpB,IAAKC,GAAe6B,YACnB9D,GAAU,GACV,MACD,KAAKiC,GAAe8B,UACnB/D,GAAU,IACV,MACD,KAAKiC,GAAegC,MACnBjE,GAAU,GACV,MACD,KAAKiC,GAAeiC,EACnBlE,GAAU,IACV,MACD,KAAKiC,GAAeM,EACnBvC,GAAU,IACV,MACD,KAAKiC,GAAekC,EACnBnE,GAAU,IACV,MACD,KAAKiC,GAAemC,EACnBpE,GAAU,IACV,MACD,KAAKiC,GAAeoC,EACnBrE,GAAU,GACV,MACD,KAAKiC,GAAeqC,EACnB,GAAIC,GAAK9C,EAAc,GAAG,EACtB8C,IAAM,EACTvE,GAAUwE,OAAOC,aAAaF,GAE9BzB,EAAYC,EAAU2B,cAEvB,MACD,SACC5B,EAAYC,EAAU4B,uBAExBzB,EAAQlB,GAUV,MAAOhC,GAGR,QAAA4E,KAOC,GALA/C,EAAQ,GACRiB,EAAYC,EAAUC,KAEtBN,EAAcV,EAEXA,GAAO9B,EAGT,MADAwC,GAAcxC,EACPyC,EAAQC,EAAWiC,GAG3B,IAAIC,GAAOvD,EAAKQ,WAAWC,EAE3B,IAAI+C,EAAaD,GAAO,CACvB,EACC9C,KACAH,GAAS2C,OAAOC,aAAaK,GAC7BA,EAAOvD,EAAKQ,WAAWC,SACf+C,EAAaD,GAEtB,OAAOnC,GAAQC,EAAWoC,OAI3B,GAAIhB,EAAYc,GAOf,MANA9C,KACAH,GAAS2C,OAAOC,aAAaK,GACzBA,IAAS7C,EAAegD,gBAAkB1D,EAAKQ,WAAWC,KAASC,EAAeiD,WACrFlD,IACAH,GAAS,MAEHc,EAAQC,EAAWuC,eAG3B,QAAOL,GAEN,IAAK7C,GAAemD,UAEnB,MADApD,KACOW,EAAQC,EAAWyC,cAC3B,KAAKpD,GAAeqD,WAEnB,MADAtD,KACOW,EAAQC,EAAW2C,eAC3B,KAAKtD,GAAeuD,YAEnB,MADAxD,KACOW,EAAQC,EAAW6C,gBAC3B,KAAKxD,GAAeyD,aAEnB,MADA1D,KACOW,EAAQC,EAAW+C,iBAC3B,KAAK1D,GAAe2D,MAEnB,MADA5D,KACOW,EAAQC,EAAWiD,UAC3B,KAAK5D,GAAe6D,MAEnB,MADA9D,KACOW,EAAQC,EAAWmD,UAG3B,KAAK9D,GAAe6B,YAGnB,MAFA9B,KACAH,EAAQ+B,IACDjB,EAAQC,EAAWoD,aAG3B,KAAK/D,GAAegC,MACnB,GAAIf,GAAQlB,EAAM,CAElB,IAAIT,EAAKQ,WAAWC,EAAM,KAAOC,EAAegC,MAAO,CAGtD,IAFAjC,GAAO,EAEM9B,EAAN8B,IACFgC,EAAYzC,EAAKQ,WAAWC,KAGhCA,GAID,OADAH,GAAQN,EAAK+B,UAAUJ,EAAOlB,GACvBW,EAAQC,EAAWqD,kBAI3B,GAAI1E,EAAKQ,WAAWC,EAAM,KAAOC,EAAeiE,SAAU,CACzDlE,GAAO,CAIP,KAFA,GAAImE,GAAajG,EAAM,EACnBkG,GAAgB,EACPD,EAANnE,GAAkB,CACxB,GAAIF,GAAKP,EAAKQ,WAAWC,EAEzB,IAAIF,IAAOG,EAAeiE,UAAY3E,EAAKQ,WAAWC,EAAM,KAAOC,EAAegC,MAAO,CACxFjC,GAAO,EACPoE,GAAgB,CAChB,OAEDpE,IASD,MANKoE,KACJpE,IACAc,EAAYC,EAAUsD,wBAGvBxE,EAAQN,EAAK+B,UAAUJ,EAAOlB,GACvBW,EAAQC,EAAW0D,mBAK3B,MAFAzE,IAAS2C,OAAOC,aAAaK,GAC7B9C,IACOW,EAAQC,EAAWC,OAG3B,KAAKZ,GAAe0B,MAGnB,GAFA9B,GAAS2C,OAAOC,aAAaK,GAC7B9C,IACIA,IAAQ9B,IAAQiD,EAAQ5B,EAAKQ,WAAWC,IAC3C,MAAOW,GAAQC,EAAWC,OAK5B,KAAKZ,GAAeC,GACpB,IAAKD,GAAesE,GACpB,IAAKtE,GAAeuE,GACpB,IAAKvE,GAAewE,GACpB,IAAKxE,GAAeyE,GACpB,IAAKzE,GAAe0E,GACpB,IAAK1E,GAAe2E,GACpB,IAAK3E,GAAe4E,GACpB,IAAK5E,GAAe6E,GACpB,IAAK7E,GAAeE,GAEnB,MADAN,IAASoB,IACFN,EAAQC,EAAWmE,cAE3B,SAEC,KAAa7G,EAAN8B,GAAagF,EAA0BlC,IAC7C9C,IACA8C,EAAOvD,EAAKQ,WAAWC,EAExB,IAAIU,IAAgBV,EAAK,CAGxB,OAFAH,EAAQN,EAAK+B,UAAUZ,EAAaV,IAGnC,IAAK,OAAQ,MAAOW,GAAQC,EAAWqE,WACvC,KAAK,QAAS,MAAOtE,GAAQC,EAAWsE,YACxC,KAAK,OAAQ,MAAOvE,GAAQC,EAAWuE,YAExC,MAAOxE,GAAQC,EAAWC,QAK3B,MAFAhB,IAAS2C,OAAOC,aAAaK,GAC7B9C,IACOW,EAAQC,EAAWC,SAI7B,QAAAmE,GAAmClC,GAClC,GAAIC,EAAaD,IAASd,EAAYc,GACrC,OAAO,CAER,QAAQA,GACP,IAAK7C,GAAeqD,WACpB,IAAKrD,GAAeyD,aACpB,IAAKzD,GAAemD,UACpB,IAAKnD,GAAeuD,YACpB,IAAKvD,GAAe6B,YACpB,IAAK7B,GAAe2D,MACpB,IAAK3D,GAAe6D,MACnB,OAAO,EAET,OAAO,EAIR,QAAAsB,KACC,GAAIpH,EACJ,GACCA,GAAS4E,UACD5E,GAAU4C,EAAWqD,mBAAqBjG,GAAU4C,EAAWoC,OACxE,OAAOhF,GAlVkC,SAAAwB,IAAAA,GAAA,EAE1C,IAAIQ,GAAM,EACT9B,EAAMqB,EAAKpB,OACX0B,EAAe,GACfa,EAAc,EACdC,EAAmBC,EAAWC,QAC9BC,EAAsBC,EAAUC,IA8UjC,QACCR,YAAaA,EACb6E,YAAa,WAAM,MAAArF,IACnBsF,KAAM9F,EAAe4F,EAAoBxC,EACzC2C,SAAU,WAAM,MAAA5E,IAChB6E,cAAe,WAAM,MAAA3F,IACrB4F,eAAgB,WAAM,MAAA/E,IACtBgF,eAAgB,WAAM,MAAA1F,GAAMU,GAC5BiF,cAAe,WAAM,MAAA7E,KAIvB,QAAAiC,GAAsBjD,GACrB,MAAOA,KAAOG,EAAe2F,OAAS9F,IAAOG,EAAe4F,KAAO/F,IAAOG,EAAe6F,aAAehG,IAAOG,EAAe8F,UAC7HjG,IAAOG,EAAe+F,kBAAoBlG,IAAOG,EAAegG,OAASnG,GAAMG,EAAeiG,QAAUpG,GAAMG,EAAekG,gBAC7HrG,IAAOG,EAAemG,oBAAsBtG,IAAOG,EAAeoG,mBAAqBvG,IAAOG,EAAeqG,kBAAoBxG,IAAOG,EAAesG,cAGzJ,QAAAvE,GAAqBlC,GACpB,MAAOA,KAAOG,EAAeiD,UAAYpD,IAAOG,EAAegD,gBAAkBnD,IAAOG,EAAeuG,eAAiB1G,IAAOG,EAAewG,mBAG/I,QAAAtF,GAAiBrB,GAChB,MAAOA,IAAMG,EAAeC,IAAMJ,GAAMG,EAAeE,GAkJxD,QAAAuG,GAA8BnH,EAAaoH,GAE1C,GAECC,GAEA5G,EAJG6G,EAAWvH,EAAcC,GAC5BuH,KAEAC,EAAS,CAGV,GAGC,QAFA/G,EAAM6G,EAASxB,cACfuB,EAAOC,EAASvB,QAEf,IAAK1E,GAAWqD,kBAChB,IAAKrD,GAAW0D,mBAChB,IAAK1D,GAAWiC,IACZkE,IAAW/G,GACb8G,EAAME,KAAKzH,EAAK+B,UAAUyF,EAAQ/G,IAElB,SAAd2G,GACFG,EAAME,KAAKH,EAASrB,gBAAgByB,QAAQ,WAAYN,IAEzDI,EAASF,EAASxB,oBAGbuB,IAAShG,EAAWiC,IAE5B,OAAOiE,GAAMI,KAAK,IAmBnB,QAAAC,GAAqCC,GACpC,OAAQA,GACP,IAAKC,GAAeC,cAAe,MAAOjI,GAAAkI,SAAS,EAAuB,KAC1E,KAAKF,GAAeG,oBAAqB,MAAOnI,GAAAkI,SAAS,EAA6B,KACtF,KAAKF,GAAeI,qBAAsB,MAAOpI,GAAAkI,SAAS,EAA8B,KACxF,KAAKF,GAAeK,cAAe,MAAOrI,GAAAkI,SAAS,EAAuB,KAC1E,KAAKF,GAAeM,cAAe,MAAOtI,GAAAkI,SAAS,EAAuB,KAC1E,KAAKF,GAAeO,cAAe,MAAOvI,GAAAkI,SAAS,EAAuB,KAC1E,KAAKF,GAAeQ,mBAAoB,MAAOxI,GAAAkI,SAAS,EAA4B,KACpF,KAAKF,GAAeS,qBAAsB,MAAOzI,GAAAkI,SAAS,EAA8B,KACxF,KAAKF,GAAeU,kBAAmB,MAAO1I,GAAAkI,SAAS,EAA2B,KAClF,SACC,MAAO,IAMV,QAAAS,GAA4BnI,GAC3B,aAAeA,IACd,IAAK,UAAW,MAAO,SACvB,KAAK,SAAU,MAAO,QACtB,KAAK,SAAU,MAAO,QACtB,SAAS,MAAO,QA2ClB,QAAAoI,GAA4B1I,EAAa2I,GAWxC,QAAAC,GAAyBtI,EAAekH,EAAgB5I,EAAgBiK,GACvEC,EAAiBxI,MAAQA,EACzBwI,EAAiBtB,OAASA,EAC1BsB,EAAiBlK,OAASA,EAC1BkK,EAAiBD,KAAOA,EACxBC,EAAiBC,aAAe,OAChCC,EAAeF,EAhBhB,GAAIG,MACAC,EAAuB,GAAIC,QAC3BH,EAAsB,OACpBF,GACLxI,MAAO,OACPkH,OAAQ,OACR5I,OAAQ,OACRiK,KAAM,QAEHO,GAAkB,CAStB,KAECC,EAAMrJ,GACLsJ,cAAe,SAAC9B,EAAgB5I,GAC/B,GAAgB4I,GAAZmB,EACH,KAAMO,EAEPF,GAAe,OACfI,EAAkBT,EAAWnB,EAC7ByB,EAASxB,KAAK,KAEf8B,iBAAkB,SAACC,EAAchC,EAAgB5I,GAChD,GAAe4I,EAAXmB,EACH,KAAMO,EAIP,IAFAN,EAAgBY,EAAMhC,EAAQ5I,EAAQ,YACtCqK,EAASA,EAASrK,OAAS,GAAK4K,EAChBhC,EAAS5I,GAArB+J,EACH,KAAMO,IAGRO,YAAa,SAACjC,EAAgB5I,GAC7B,GAAgB4I,GAAZmB,EACH,KAAMO,EAEPF,GAAe,OACfC,EAASS,OAEVC,aAAc,SAACnC,EAAgB5I,GAC9B,GAAgB4I,GAAZmB,EACH,KAAMO,EAEPF,GAAe,OACfC,EAASxB,KAAK,IAEfmC,WAAY,SAACpC,EAAgB5I,GAC5B,GAAgB4I,GAAZmB,EACH,KAAMO,EAEPF,GAAe,OACfC,EAASS,OAEVG,eAAgB,SAACvJ,EAAYkH,EAAgB5I,GAC5C,GAAe4I,EAAXmB,EACH,KAAMO,EAIP,IAFAN,EAAgBtI,EAAOkH,EAAQ5I,EAAQ6J,EAAmBnI,IAE1CkH,EAAS5I,GAArB+J,EACH,KAAMO,IAGRY,YAAa,SAACC,EAAavC,EAAgB5I,GAC1C,GAAgB4I,GAAZmB,EACH,KAAMO,EAEP,IAAY,MAARa,GAAqC,aAAtBf,EAAaH,KAC/BG,EAAaD,aAAevB,EAC5B4B,GAAkB,EAClBJ,EAAe,WACT,IAAY,MAARe,EAAa,CACvB,GAAIC,GAAOf,EAASA,EAASrK,OAAS,EAClB,iBAAToL,GACVf,EAASA,EAASrK,OAAS,GAAKoL,EAAO,GAEvCZ,GAAkB,EAClBH,EAASA,EAASrK,OAAS,GAAK,IAEjCoK,EAAe,WAIjB,MAAO9G,GACR,GAAIA,IAAMgH,EACT,KAAMhH,GAOR,MAHsC,KAAlC+G,EAASA,EAASrK,OAAS,IAC9BqK,EAASS,OAGTO,KAAMhB,EACND,aAAAA,EACAI,gBAAAA,EACAc,QAAS,SAACC,GAET,IAAK,GADDC,GAAI,EACC1L,EAAI,EAAG0L,EAAID,EAAQvL,QAAUF,EAAIuK,EAASrK,OAAQF,IAC1D,GAAIyL,EAAQC,KAAOnB,EAASvK,IAAqB,MAAfyL,EAAQC,GACzCA,QACM,IAAmB,OAAfD,EAAQC,GAClB,OAAO,CAGT,OAAOA,KAAMD,EAAQvL,SAaxB,QAAAyL,GAAsBrK,EAAasK,EAA2BC,GAK7D,QAAAC,GAAiBlK,GACZmK,MAAMC,QAAQC,GACRA,EAAelD,KAAKnH,GACnBsK,IACVD,EAAcC,GAAmBtK,GATD,SAAAgK,IAAAA,KAClC,IAAIM,GAA2B,KAC3BD,KACAE,KAUAC,GACHxB,cAAe,WACd,GAAIyB,KACJP,GAAQO,GACRF,EAAgBpD,KAAKkD,GACrBA,EAAgBI,EAChBH,EAAkB,MAEnBrB,iBAAkB,SAACC,GAClBoB,EAAkBpB,GAEnBC,YAAa,WACZkB,EAAgBE,EAAgBnB,OAEjCC,aAAc,WACb,GAAIqB,KACJR,GAAQQ,GACRH,EAAgBpD,KAAKkD,GACrBA,EAAgBK,EAChBJ,EAAkB,MAEnBhB,WAAY,WACXe,EAAgBE,EAAgBnB,OAEjCG,eAAgBW,EAChBS,QAAQ,SAACC,GACRZ,EAAO7C,MAAMyD,MAAOA,KAItB,OADA7B,GAAMrJ,EAAM8K,EAASP,GACdI,EAAc,GAOtB,QAAAQ,GAA0BnL,EAAasK,EAA2BC,GAGjE,QAAAa,GAAgCC,GACJ,aAAvBV,EAAc9B,OACjB8B,EAAc/L,OAASyM,EAAYV,EAAcnD,OACjDmD,EAAgBA,EAAcW,QAIhC,QAAAd,GAAiBe,GAGhB,MAFAZ,GAAca,SAAS/D,KAAK8D,GAC5BH,EAAuBG,EAAU/D,OAAS+D,EAAU3M,QAC7C2M,EAb8B,SAAAjB,IAAAA,KACtC,IAAIK,IAAyB9B,KAAM,QAASrB,OAAQ,GAAI5I,OAAQ,GAAI4M,aAehEV,GACHxB,cAAe,SAAC9B,GACfmD,EAAgBH,GAAU3B,KAAM,SAAUrB,OAAAA,EAAQ5I,OAAQ,GAAI0M,OAAQX,EAAea,eAEtFjC,iBAAkB,SAACC,EAAchC,EAAgB5I,GAChD+L,EAAgBH,GAAU3B,KAAM,WAAYrB,OAAAA,EAAQ5I,OAAQ,GAAI0M,OAAQX,EAAea,cACvFb,EAAca,SAAS/D,MAAOoB,KAAM,SAAUvI,MAAOkJ,EAAMhC,OAAAA,EAAQ5I,OAAAA,EAAQ0M,OAAQX,KAEpFlB,YAAa,SAACjC,EAAgB5I,GAC7BwM,EAAuB5D,GACvBmD,EAAc/L,OAAS4I,EAAS5I,EAAS+L,EAAcnD,OACvDmD,EAAgBA,EAAcW,QAE/B3B,aAAc,SAACnC,EAAgB5I,GAC9B+L,EAAgBH,GAAU3B,KAAM,QAASrB,OAAAA,EAAQ5I,OAAQ,GAAI0M,OAAQX,EAAea,eAErF5B,WAAY,SAACpC,EAAgB5I,GAC5B+L,EAAc/L,OAAS4I,EAAS5I,EAAS+L,EAAcnD,OACvDmD,EAAgBA,EAAcW,QAE/BzB,eAAgB,SAACvJ,EAAYkH,EAAgB5I,GAC5C4L,GAAU3B,KAAMJ,EAAmBnI,GAAQkH,OAAAA,EAAQ5I,OAAAA,EAAQ0M,OAAQX,EAAerK,MAAAA,KAEnFwJ,YAAa,SAACC,EAAavC,EAAgB5I,GACf,aAAvB+L,EAAc9B,OACL,MAARkB,EACHY,EAAc5B,aAAevB,EACX,MAARuC,GACVqB,EAAuB5D,KAI1ByD,QAAQ,SAACC,GACRZ,EAAO7C,MAAMyD,MAAOA,KAGtB7B,GAAMrJ,EAAM8K,EAASP,EAErB,IAAI9L,GAASkM,EAAca,SAAS,EAIpC,OAHI/M,UACIA,GAAO6M,OAER7M,EAGR,QAAAgN,GAAmCC,EAAYzB,GAC9C,GAAKyB,EAAL,CAIA,IAAoB,GADhBC,GAAOD,EACSE,EAAA,EAAAC,EAAA5B,EAAA2B,EAAAC,EAAAjN,OAAAgN,IAAK,CAApB,GAAIE,GAAOD,EAAAD,EACf,IAAuB,gBAAZE,GAAsB,CAChC,GAAkB,WAAdH,EAAK9C,KACR,MAGD,KAAyB,GADrBkD,IAAQ,EACaC,EAAA,EAAAC,EAAAN,EAAKH,SAALQ,EAAAC,EAAArN,OAAAoN,IAAc,CAAlC,GAAIE,GAAYD,EAAAD,EACpB,IAAIE,EAAaV,SAAS,GAAGlL,QAAUwL,EAAS,CAC/CH,EAAOO,EAAaV,SAAS,GAC7BO,GAAQ,CACR,QAGF,IAAKA,EACJ,WAEK,CACN,GAAII,GAAiBL,CACrB,IAAkB,UAAdH,EAAK9C,MAA4B,EAARsD,GAAaA,GAASR,EAAKH,SAAS5M,OAChE,MAED+M,GAAOA,EAAKH,SAASW,IAGvB,MAAOR,IAGR,QAAAS,GAA6BT,GAC5B,GAAkB,UAAdA,EAAK9C,KACR,MAAO8C,GAAKH,SAASa,IAAID,EACnB,IAAkB,WAAdT,EAAK9C,KAAmB,CAElC,IAAiB,GADbyD,MACaV,EAAA,EAAAI,EAAAL,EAAKH,SAALI,EAAAI,EAAApN,OAAAgN,IAAc,CAA1B,GAAIW,GAAIP,EAAAJ,EACZU,GAAIC,EAAKf,SAAS,GAAGlL,OAAS8L,EAAaG,EAAKf,SAAS,IAE1D,MAAOc,GAER,MAAOX,GAAKrL,MAOb,QAAA+I,GAAsBrJ,EAAa8K,EAAsBP,GAIxD,QAAAiC,GAAsBC,GACrB,MAAOA,GAAgB,WAAM,MAAAA,GAAcnF,EAASpB,iBAAkBoB,EAASnB,mBAAoB,WAAM,OAAA,GAE1G,QAAAuG,GAA0BD,GACzB,MAAOA,GAAgB,SAACE,GAAW,MAAAF,GAAcE,EAAKrF,EAASpB,iBAAkBoB,EAASnB,mBAAoB,WAAM,OAAA,GAarH,QAAA9C,KACC,OAAa,CACZ,GAAIjC,GAAQkG,EAASvB,MACrB,QAAQ3E,GACP,IAAKC,GAAWqD,kBAChB,IAAKrD,GAAW0D,mBACX6H,GACHC,EAAY/E,EAAeC,cAE5B,MACD,KAAK1G,GAAWC,QACfuL,EAAY/E,EAAeC,cAC3B,MACD,KAAK1G,GAAWoC,OAChB,IAAKpC,GAAWuC,gBACf,KACD,SACC,MAAOxC,KAKX,QAAAyL,GAAqB3B,EAAsB4B,EAAmCC,GAE7E,GAF0C,SAAAD,IAAAA,MAAmC,SAAAC,IAAAA,MAC7E9B,EAAQC,GACJ4B,EAAelO,OAASmO,EAAUnO,OAAS,EAE9C,IADA,GAAIwC,GAAQkG,EAAStB,WACd5E,IAAUC,EAAWiC,KAAK,CAChC,GAAsC,KAAlCwJ,EAAeE,QAAQ5L,GAAe,CACzCiC,GACA,OACM,GAAiC,KAA7B0J,EAAUC,QAAQ5L,GAC5B,KAEDA,GAAQiC,KAKX,QAAA4J,GAAqBC,GACpB,GAAI5F,EAAStB,aAAe3E,EAAWoD,cACtC,OAAO,CAER,IAAInE,GAAQgH,EAASrB,eAOrB,OANIiH,GACHrD,EAAevJ,GAEfiJ,EAAiBjJ,GAElB+C,KACO,EAGR,QAAA8J,KACC,OAAQ7F,EAAStB,YAChB,IAAK3E,GAAWmE,eACf,GAAIlF,GAAQ,CACZ,KACCA,EAAQ8M,KAAK/C,MAAM/C,EAASrB,iBACP,gBAAV3F,KACVuM,EAAY/E,EAAeG,qBAC3B3H,EAAQ,GAER,MAAO4B,GACR2K,EAAY/E,EAAeG,qBAE5B4B,EAAevJ,EACf,MACD,KAAKe,GAAWuE,YACfiE,EAAe,KACf,MACD,KAAKxI,GAAWqE,YACfmE,GAAe,EACf,MACD,KAAKxI,GAAWsE,aACfkE,GAAe,EACf,MACD,SACC,OAAO,EAGT,MADAxG,MACO,EAGR,QAAAgK,KACC,MAAKJ,IAAY,IAIb3F,EAAStB,aAAe3E,EAAWiD,YACtCwF,EAAY,KACZzG,IAEKiK,KACJT,EAAY/E,EAAeK,kBAAoB9G,EAAW2C,gBAAiB3C,EAAWmD,cAGvFqI,EAAY/E,EAAeM,kBAAoB/G,EAAW2C,gBAAiB3C,EAAWmD,cAEhF,IAbNqI,EAAY/E,EAAeI,yBAA2B7G,EAAW2C,gBAAiB3C,EAAWmD,cACtF,GAeT,QAAA+I,KACC,GAAIjG,EAAStB,aAAe3E,EAAWyC,eACtC,OAAO,CAERwF,KACAjG,GAGA,KADA,GAAImK,IAAa,EACVlG,EAAStB,aAAe3E,EAAW2C,iBAAmBsD,EAAStB,aAAe3E,EAAWiC,KAC3FgE,EAAStB,aAAe3E,EAAWmD,YACjCgJ,GACJX,EAAY/E,EAAeK,qBAE5B2B,EAAY,KACZzG,KACUmK,GACVX,EAAY/E,EAAeO,qBAEvBgF,KACJR,EAAY/E,EAAeK,kBAAoB9G,EAAW2C,gBAAiB3C,EAAWmD,aAEvFgJ,GAAa,CAQd,OANA/D,KACInC,EAAStB,aAAe3E,EAAW2C,gBACtC6I,EAAY/E,EAAeQ,oBAAqBjH,EAAW2C,qBAE3DX,KAEM,EAGR,QAAAoK,KACC,GAAInG,EAAStB,aAAe3E,EAAW6C,iBACtC,OAAO,CAERyF,KACAtG,GAGA,KADA,GAAImK,IAAa,EACVlG,EAAStB,aAAe3E,EAAW+C,mBAAqBkD,EAAStB,aAAe3E,EAAWiC,KAC7FgE,EAAStB,aAAe3E,EAAWmD,YACjCgJ,GACJX,EAAY/E,EAAeK,qBAE5B2B,EAAY,KACZzG,KACUmK,GACVX,EAAY/E,EAAeO,qBAEvBiF,KACJT,EAAY/E,EAAeK,kBAAoB9G,EAAW+C,kBAAmB/C,EAAWmD,aAEzFgJ,GAAa,CAQd,OANA5D,KACItC,EAAStB,aAAe3E,EAAW+C,kBACtCyI,EAAY/E,EAAeS,sBAAuBlH,EAAW+C,uBAE7Df,KAEM,EAGR,QAAAiK,KACC,MAAOG,MAAgBF,KAAiBN,GAAY,IAASE,IAzL9D,GAAI7F,GAAWvH,EAAcC,GAAM,GAS/BsJ,EAAgBkD,EAAa1B,EAAQxB,eACxCC,EAAmBmD,EAAc5B,EAAQvB,kBACzCE,EAAc+C,EAAa1B,EAAQrB,aACnCE,EAAe6C,EAAa1B,EAAQnB,cACpCC,EAAa4C,EAAa1B,EAAQlB,YAClCC,EAAiB6C,EAAc5B,EAAQjB,gBACvCC,EAAc4C,EAAc5B,EAAQhB,aACpCmB,EAAUyB,EAAc5B,EAAQG,SAE7B2B,EAAmBrC,GAAWA,EAAQqC,gBA2K1C,OADAvJ,KACIiE,EAAStB,aAAe3E,EAAWiC,KAC/B,EAEHgK,KAIDhG,EAAStB,aAAe3E,EAAWiC,KACtCuJ,EAAY/E,EAAeU,0BAErB,IANNqE,EAAY/E,EAAeK,sBACpB,IArpCT,SAAY3G,GACXA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,uBAAA,GAAA,yBACAA,EAAAA,EAAA,sBAAA,GAAA,wBACAA,EAAAA,EAAA,sBAAA,GAAA,wBACAA,EAAAA,EAAA,eAAA,GAAA,iBACAA,EAAAA,EAAA,uBAAA,GAAA,0BANWzC,EAAAyC,YAAAzC,EAAAyC,cAAZ,IAAYA,GAAAzC,EAAAyC,WASZ,SAAYH,GACXA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,eAAA,GAAA,iBACAA,EAAAA,EAAA,gBAAA,GAAA,kBACAA,EAAAA,EAAA,iBAAA,GAAA,mBACAA,EAAAA,EAAA,kBAAA,GAAA,oBACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,aAAA,GAAA,eACAA,EAAAA,EAAA,cAAA,IAAA,gBACAA,EAAAA,EAAA,eAAA,IAAA,iBACAA,EAAAA,EAAA,kBAAA,IAAA,oBACAA,EAAAA,EAAA,mBAAA,IAAA,qBACAA,EAAAA,EAAA,gBAAA,IAAA,kBACAA,EAAAA,EAAA,OAAA,IAAA,SACAA,EAAAA,EAAA,IAAA,IAAA,OAjBWtC,EAAAsC,aAAAtC,EAAAsC,eAAZ,IAAYA,GAAAtC,EAAAsC,UA6DItC,GAAAgB,cAAaA,CA+W7B,IAAKW,IAAL,SAAKA,GACJA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,kBAAA,KAAA,oBAEAA,EAAAA,EAAA,SAAA,IAAA,WACAA,EAAAA,EAAA,eAAA,IAAA,iBACAA,EAAAA,EAAA,cAAA,MAAA,gBACAA,EAAAA,EAAA,mBAAA,MAAA,qBAIAA,EAAAA,EAAA,SAAA,KAAA,WAGAA,EAAAA,EAAA,MAAA,IAAA,QACAA,EAAAA,EAAA,iBAAA,KAAA,mBACAA,EAAAA,EAAA,OAAA,MAAA,SACAA,EAAAA,EAAA,OAAA,MAAA,SACAA,EAAAA,EAAA,QAAA,MAAA,UACAA,EAAAA,EAAA,QAAA,MAAA,UACAA,EAAAA,EAAA,gBAAA,MAAA,kBACAA,EAAAA,EAAA,eAAA,MAAA,iBACAA,EAAAA,EAAA,cAAA,MAAA,gBACAA,EAAAA,EAAA,YAAA,MAAA,cACAA,EAAAA,EAAA,iBAAA,MAAA,mBACAA,EAAAA,EAAA,UAAA,MAAA,YACAA,EAAAA,EAAA,UAAA,MAAA,YACAA,EAAAA,EAAA,eAAA,MAAA,iBACAA,EAAAA,EAAA,mBAAA,MAAA,qBACAA,EAAAA,EAAA,iBAAA,OAAA,mBACAA,EAAAA,EAAA,kBAAA,MAAA,oBACAA,EAAAA,EAAA,MAAA,MAAA,QAEAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IAEAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KAEAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IAEAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IAEAA,EAAAA,EAAA,UAAA,IAAA,YACAA,EAAAA,EAAA,SAAA,IAAA,WACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,UAAA,IAAA,YACAA,EAAAA,EAAA,IAAA,KAAA,MACAA,EAAAA,EAAA,MAAA,IAAA,QACAA,EAAAA,EAAA,WAAA,KAAA,aACAA,EAAAA,EAAA,aAAA,IAAA,eACAA,EAAAA,EAAA,WAAA,IAAA,aACAA,EAAAA,EAAA,MAAA,IAAA,QACAA,EAAAA,EAAA,MAAA,IAAA,QACAA,EAAAA,EAAA,IAAA,IAAA,MACAA,EAAAA,EAAA,YAAA,IAAA,cACAA,EAAAA,EAAA,OAAA,IAAA,SACAA,EAAAA,EAAA,YAAA,IAAA,cACAA,EAAAA,EAAA,YAAA,IAAA,cACAA,EAAAA,EAAA,SAAA,IAAA,WACAA,EAAAA,EAAA,MAAA,IAAA,QACAA,EAAAA,EAAA,UAAA,KAAA,YACAA,EAAAA,EAAA,YAAA,IAAA,cACAA,EAAAA,EAAA,UAAA,IAAA,YACAA,EAAAA,EAAA,QAAA,IAAA,UACAA,EAAAA,EAAA,KAAA,IAAA,OACAA,EAAAA,EAAA,SAAA,IAAA,WACAA,EAAAA,EAAA,UAAA,IAAA,YACAA,EAAAA,EAAA,YAAA,IAAA,cACAA,EAAAA,EAAA,MAAA,IAAA,QACAA,EAAAA,EAAA,MAAA,KAAA,QAEAA,EAAAA,EAAA,UAAA,GAAA,YACAA,EAAAA,EAAA,SAAA,IAAA,WACAA,EAAAA,EAAA,cAAA,OAAA,gBACAA,EAAAA,EAAA,IAAA,GAAA,MACAA,EAAAA,EAAA,YAAA,IAAA,eAtIIA,IAAAA,OA+IW3B,EAAAoI,cAAaA,EAiC7B,SAAYW,GACXA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,oBAAA,GAAA,sBACAA,EAAAA,EAAA,qBAAA,GAAA,uBACAA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,mBAAA,GAAA,qBACAA,EAAAA,EAAA,qBAAA,GAAA,uBACAA,EAAAA,EAAA,kBAAA,GAAA,qBATW/I,EAAA+I,iBAAA/I,EAAA+I,mBAAZ,IAAYA,GAAA/I,EAAA+I,cAYI/I,GAAA6I,qBAAoBA,EAkEpB7I,EAAA2J,YAAWA,EA8HX3J,EAAAsL,MAAKA,EAkDLtL,EAAAoM,UAASA,EA6DTpM,EAAA0M,mBAAkBA,EAgClB1M,EAAAqN,aAAYA,EAiBZrN,EAAAsK,MAAKA,IFgGrBxK,OAAOP,EAAI,GAAIC,GAAK,EAAE,EAAE,EAAE,IAAK,SAAUO,EAASC,EAAS2O,EAAMC,GGrjCjE,YAMA,SAAAC,GAA0CC,EAAkBC,GAC3D,OACCC,8BAA8B,EAC9BC,gBAAiB,WAAM,MAAA,IAAIC,GAAUJ,EAAM,KAAM,MAAM,IACvDK,SAAU,SAACC,EAAMC,EAAOC,EAAcC,GAAkB,MAAAJ,GAASL,EAAMC,EAAiBK,EAAkBC,EAAOC,EAAaC,KAmDhI,QAAAJ,GAAkBL,EAAkBU,EAAkBJ,EAAaC,EAAiBC,EAAwBC,GAAxB,SAAAD,IAAAA,EAAA,EAGnF,IAAIG,GAA6B,EAChCC,GAAe,CAEhB,QAAOL,EAAM7M,WACZ,IAAKmM,GAAKlM,UAAUc,sBACnB6L,EAAO,IAAMA,EACbK,EAA6B,CAC7B,MACD,KAAKd,GAAKlM,UAAUsD,uBACnBqJ,EAAO,KAAOA,EACdK,EAA6B,EAI/B,GACCnH,GACAqH,EAFGC,EAAUjB,EAAK3N,cAAcoO,GAGhCS,EAAeR,EAAMQ,YAStB,KAPAF,GACCG,UACAC,iBAAkBX,EAAKvP,OACvBmQ,SAAUX,EAAMY,QAChBC,kBAAoBC,WAAY,EAAGrB,KAAMA,OAG9B,CAEX,GAAIrG,GAAS6G,EAAcM,EAAQ7I,cAClC+C,EAAO,EAGR,IADAxB,EAAOsH,EAAQ5I,OACZsB,IAASqG,EAAKrM,WAAWiC,IAC3B,KAID,IAAIkE,IAAW6G,EAAcM,EAAQ7I,cACpC,KAAM,IAAIqJ,OAAM,mDAAqDhB,EAAKiB,OAAOT,EAAQ7I,cAAe,GAYzG,QAPG2I,IACFjH,GAAUgH,GAEXC,EAAeD,EAA6B,EAIrCnH,GACN,IAAKqG,GAAKrM,WAAWyC,eACpB+E,EAAO8E,EAAe3O,mBACtB4P,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAW2C,gBACpB6E,EAAO8E,EAAe3O,mBACtB4P,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAW6C,iBACpB2E,EAAO8E,EAAe1O,kBACtB2P,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAW+C,kBACpByE,EAAO8E,EAAe1O,kBACtB2P,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAWiD,WACpBuE,EAAO8E,EAAezO,kBACtB0P,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAWmD,WACpBqE,EAAO8E,EAAexO,kBACtByP,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAWqE,YACrB,IAAKgI,GAAKrM,WAAWsE,aACpBkD,EAAO8E,EAAevO,oBACtBwP,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAWuE,YACpBiD,EAAO8E,EAAetO,iBACtBuP,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAWoD,cACpBoE,EAAO+F,EAAejB,EAAerO,mBAAqBqO,EAAenO,oBACzEoP,GAAe,CACf,MACD,KAAKlB,GAAKrM,WAAWmE,eACpBqD,EAAO8E,EAAepO,mBACtBqP,GAAe,EAKjB,GAAGL,EACF,OAAQlH,GACP,IAAKqG,GAAKrM,WAAWqD,kBACpBmE,EAAO8E,EAAejO,kBACtB,MACD,KAAKgO,GAAKrM,WAAW0D,mBACpB8D,EAAO8E,EAAelO,oBAKzBiP,EAAIK,SAAW,GAAId,GAAUG,EAAMiB,UAAWjB,EAAMkB,eAAgBX,EAAQvI,gBAAiBwI,GAC7FF,EAAIG,OAAOpH,MACVyH,WAAY1H,EACZqB,KAAMA,IAIR,MAAO6F,GA3KQ3P,EAAA6O,0BAAyBA,CAQzC,IAAAK,GAAA,WAQC,QAAAA,GAAYJ,EAAmBO,EAAqB7M,EAA2BqN,GAC9EW,KAAKC,MAAQ3B,EACb0B,KAAKE,OAASrB,EACdmB,KAAKhO,UAAYA,EACjBgO,KAAKX,aAAeA,EAiCtB,MA9BQX,GAAAyB,UAAAV,MAAP,WACC,MAAO,IAAIf,GAAUsB,KAAKC,MAAOD,KAAKE,OAAQF,KAAKhO,UAAWgO,KAAKX,eAG7DX,EAAAyB,UAAAC,OAAP,SAAcC,GACb,MAAGA,KAAUL,MACL,EAEJK,GAAWA,YAAiB3B,GAGzBsB,KAAKhO,YAA2BqO,EAAOrO,WAC7CgO,KAAKX,eAA8BgB,EAAOhB,cAHnC,GAMFX,EAAAyB,UAAAL,QAAP,WACC,MAAOE,MAAKC,OAGNvB,EAAAyB,UAAAxB,SAAP,SAAgB2B,GACf,KAAM,IAAIV,QAGJlB,EAAAyB,UAAAJ,aAAP,WACC,MAAOC,MAAKE,QAGNxB,EAAAyB,UAAAI,aAAP,SAAoB1B,GACnBmB,KAAKE,OAASrB,GAEhBH,MHgpCA,IAAI8B,GAAaR,MAAQA,KAAKQ,WAAc,SAAUC,EAAGrN,GAErD,QAASsN,KAAOV,KAAKW,YAAcF,EADnC,IAAK,GAAIG,KAAKxN,GAAOA,EAAEyN,eAAeD,KAAIH,EAAEG,GAAKxN,EAAEwN,GAEnDH,GAAEN,UAAkB,OAAN/M,EAAawG,OAAOtJ,OAAO8C,IAAMsN,EAAGP,UAAY/M,EAAE+M,UAAW,GAAIO,KAE/EI,EAAcd,MAAQA,KAAKc,YAAe,SAAUC,EAAYC,EAAQC,EAAKC,GAC7E,GAA2HT,GAAvHU,EAAIC,UAAU/R,OAAQiE,EAAQ,EAAJ6N,EAAQH,EAAkB,OAATE,EAAgBA,EAAOtH,OAAOyH,yBAAyBL,EAAQC,GAAOC,CACrH,IAAuB,gBAAZI,UAAoD,kBAArBA,SAAQC,SAAyBjO,EAAIgO,QAAQC,SAASR,EAAYC,EAAQC,EAAKC,OACpH,KAAK,GAAI/R,GAAI4R,EAAW1R,OAAS,EAAGF,GAAK,EAAGA,KAASsR,EAAIM,EAAW5R,MAAImE,GAAS,EAAJ6N,EAAQV,EAAEnN,GAAK6N,EAAI,EAAIV,EAAEO,EAAQC,EAAK3N,GAAKmN,EAAEO,EAAQC,KAAS3N,EAChJ,OAAO6N,GAAI,GAAK7N,GAAKsG,OAAO4H,eAAeR,EAAQC,EAAK3N,GAAIA,GAE5DmO,EAAWzB,MAAQA,KAAKyB,SAAY,SAAUC,EAAYC,GAC1D,MAAO,UAAUX,EAAQC,GAAOU,EAAUX,EAAQC,EAAKS,IAE3DpS,QAAOP,EAAI,GAAIC,GAAK,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAK,SAAUO,EAASC,EAASoS,EAAOC,EAAUC,EAAcC,EAAgBC,EAAiBC,EAAUC,EAA4BC,EAAiBC,EAAiCC,GIztC3O,YAiBA,IAAAC,GAAA,SAAAC,GA6BC,QAAAD,GACCE,EACuBC,EACPC,GAhClB,GAAAC,GAAA3C,IAkCEuC,GAAAK,KAAA5C,KAAMwC,EAAWK,IACjB7C,KAAK8C,mBAAqB,GAAIf,GAAAgB,kBAAyCP,EAAY,sCAAuC,aAAc,KAAMC,GAC9IzC,KAAKgD,eAAiBN,EAEtB1C,KAAKiD,oBAAsBnB,EAAazD,0BAA0B2B,MAAM,GAExEoC,EAAAc,8BAA8BC,SAASnD,KAAKoD,QAASd,EAASe,aAE9DzB,EAAM0B,sBAAsBH,SAASnD,KAAKoD,SACzCG,aAAc,SAACC,EAAOpK,EAAUvH,GAC/B,MAAOwQ,GAAAoB,sBAAsB5R,EAAO8Q,EAAKe,cAAcF,EAAMG,IAAKvK,OAEjE,GAEH4G,KAAK4D,sBAAwB5D,KAE7BA,KAAK6D,cAAgB7D,KAGrB4B,EAAMkC,+BAA+BX,SAASnD,KAAKoD,SAClDW,uBAAwB,SAACP,EAAO3R,GAC/B,MAAOwQ,GAAAoB,sBAAsB5R,EAAO8Q,EAAKqB,wBAAwBR,EAAMG,SAEtE,GAEH/B,EAAMqC,uCAAuCd,SAASnD,KAAKoD,SAC1Dc,+BAAgC,SAACV,EAAOxI,EAASnJ,GAChD,MAAOwQ,GAAAoB,sBAAsB5R,EAAO8Q,EAAKwB,gCAAgCX,EAAMG,IAAK3I,OAEnF,GAEH4G,EAAMwC,4CAA4CjB,SAASnD,KAAKoD,SAC/DiB,oCAAqC,SAACb,EAAOc,EAAOtJ,EAASnJ,GAC5D,MAAOwQ,GAAAoB,sBAAsB5R,EAAO8Q,EAAK4B,qCAAqCf,EAAMG,IAAKW,EAAOtJ,OAE/F,GAEH4G,EAAM4C,gBAAgBrB,SAASnD,KAAKoD,SACnCqB,qBACAC,0BAA0B,EAC1BC,uBAAwB,SAACnB,EAAOpK,EAAUvH,GACzC,MAAOwQ,GAAAoB,sBAAsB5R,EAAO8Q,EAAKiC,wBAAwBpB,EAAMG,IAAKvK,OAE3E,GA8EL,MA3J8BoH,GAAA8B,EAAAC,GAgFtBD,EAAAnC,UAAA0E,aAAP,WAAA,GAAAlC,GAAA3C,IACC,IAAIA,KAAKgD,eAAe8B,eAAgB,CAEvC9E,KAAK+E,yBAGL/E,KAAKgF,wBAAwBhF,KAAKiF,yBAClC,IAAIC,GAAmDrD,EAASsD,SAASC,GAAGlD,EAAAmD,WAAWC,iBACvFJ,GAAqBK,2BAA2B,SAAA5S,GAC/CgQ,EAAKqC,wBAAwBrC,EAAKsC,8BAK7B3C,EAAAnC,UAAAqF,QAAR,SAAmBC,GAClB,MAAOzF,MAAK8C,mBAAmB4C,OAAOD,IAG/BnD,EAAAnC,UAAA8E,uBAAR,WACC,GAAIC,GAAmDrD,EAASsD,SAASC,GAAGlD,EAAAmD,WAAWC,iBACvF,OAAOJ,GAAqBS,0BAGtBrD,EAAAnC,UAAAyF,UAAP,SAAiB5K,GAChB,MAAIgF,MAAKgD,eAAe8B,eAChB9E,KAAK6F,kBAAkB7K,GAEvBgF,KAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEC,aAAa/K,MAKpCsH,EAAAnC,UAAA0F,kBAAR,SAA0B7K,GACzB,MAAOgF,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEC,aAAa/K,MAInCsH,EAAAnC,UAAA6E,wBAAR,SAAgC3U,GAC/B,MAAO2P,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEE,uBAAuB3V,MAI7CiS,EAAAnC,UAAA4E,uBAAR,WACC,MAAO/E,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEG,qBAIvB3D,EAAAnC,UAAA+F,iBAAP,SAAwBC,EAAc/M,EAA8BgN,GACnE,MAAOpG,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEI,iBAAiBC,EAAU/M,EAAUgN,MAI3D9D,EAAAnC,UAAAyE,wBAAR,SAAgCuB,EAAc/M,GAC7C,MAAO4G,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEnB,uBAAuBwB,EAAU/M,MAIvDkJ,EAAAnC,UAAAuD,cAAR,SAAsByC,EAAc/M,GACnC,MAAO4G,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEvC,aAAa4C,EAAU/M,MAI7CkJ,EAAAnC,UAAA6D,wBAAR,SAAgCmC,GAC/B,MAAOnG,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAE/B,uBAAuBoC,MAI9C7D,EAAAnC,UAAAgE,gCAAP,SAAuCgC,EAAcnL,GACpD,MAAOgF,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEO,OAAOF,EAAU,KAAMnL,MAI9CsH,EAAAnC,UAAAoE,qCAAP,SAA4C4B,EAAc7B,EAA2BtJ,GACpF,MAAOgF,MAAKwF,QAAQ,SAACM,GAAM,MAAAA,GAAEO,OAAOF,EAAU7B,EAAOtJ,MAvJxCsH,EAAAe,aACbiD,YAAavE,EAAAwE,iBAAiB,MAE9BvH,UACCwH,YAAa,KACbC,cAAe,KAAM,OAGtBC,WACE,IAAK,MACL,IAAK,MAGPC,mBACGC,KAAM,IAAKC,MAAO,IAAKC,OAAQ,YAC/BF,KAAM,IAAKC,MAAO,IAAKC,OAAQ,YAC/BF,KAAM,IAAKC,MAAO,IAAKC,OAAQ,aA6F5BxE,EAAAyE,mBAAqB/E,EAAAgF,eAAe1E,EAAUA,EAASnC,UAAU0F,mBAKjEvD,EAAA2E,yBAA2BjF,EAAAgF,eAAe1E,EAAUA,EAASnC,UAAU6E,yBAKvE1C,EAAA4E,wBAA0BlF,EAAAmF,cAAc7E,EAAUA,EAASnC,UAAU4E,uBAAwB9C,EAAAmF,eAAeC,QAK5G/E,EAAAgF,kBAAoBtF,EAAAmF,cAAc7E,EAAUA,EAASnC,UAAU+F,kBAK/D5D,EAAAiF,yBAA2BvF,EAAAmF,cAAc7E,EAAUA,EAASnC,UAAUyE,yBAKtEtC,EAAAkF,eAAiBxF,EAAAmF,cAAc7E,EAAUA,EAASnC,UAAUuD,eAK5DpB,EAAAmF,yBAA2BzF,EAAAmF,cAAc7E,EAAUA,EAASnC,UAAU6D,yBAKtE1B,EAAAoF,iCAAmC1F,EAAAmF,cAAc7E,EAAUA,EAASnC,UAAUgE,iCAK9E7B,EAAAqF,sCAAwC3F,EAAAmF,cAAc7E,EAAUA,EAASnC,UAAUoE,sCAxHzFjC,EAAAxB,GJwyCUW,EAAQ,EIxyCjBU,EAAAyF,uBJyyCSnG,EAAQ,EIxyCjBQ,EAAA4F,iBJyyCQvF,IIz0CmBP,EAAA+F,aAAjBtY,GAAA8S,SAAQA,MLrBrBM,KAAA5C","file":"vs/languages/json/common/json.js","sourcesContent":["}).call(this);","/*!-----------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.4.2(1ebfb1b687c4345ac9c6da39051431a46c120a65)\n * Released under the MIT license\n * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt\n *-----------------------------------------------------------*/\n\n(function() {\nvar __m = [\"exports\",\"require\",\"vs/languages/json/common/features/jsonTokenTypes\",\"vs/nls!vs/base/common/json\",\"vs/base/common/json\",\"vs/languages/json/common/features/tokenization\",\"vs/base/common/async\",\"vs/nls\",\"vs/languages/json/common/json\",\"vs/nls!vs/languages/json/common/json\",\"vs/platform/platform\",\"vs/editor/common/modes/abstractMode\",\"vs/platform/thread/common/threadService\",\"vs/platform/thread/common/thread\",\"vs/platform/jsonschemas/common/jsonContributionRegistry\",\"vs/platform/instantiation/common/instantiation\",\"vs/editor/common/modes/languageConfigurationRegistry\",\"vs/editor/common/modes\"];\nvar __M = function(deps) {\n  var result = [];\n  for (var i = 0, len = deps.length; i < len; i++) {\n    result[i] = __m[deps[i]];\n  }\n  return result;\n};\ndefine(__m[2], __M([1,0]), function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    exports.TOKEN_DELIM_OBJECT = 'punctuation.bracket.json';\n    exports.TOKEN_DELIM_ARRAY = 'punctuation.array.json';\n    exports.TOKEN_DELIM_COLON = 'punctuation.colon.json';\n    exports.TOKEN_DELIM_COMMA = 'punctuation.comma.json';\n    exports.TOKEN_VALUE_BOOLEAN = 'support.property-value.keyword.json';\n    exports.TOKEN_VALUE_NULL = 'support.property-value.constant.other.json';\n    exports.TOKEN_VALUE_STRING = 'support.property-value.string.value.json';\n    exports.TOKEN_VALUE_NUMBER = 'support.property-value.constant.numeric.json';\n    exports.TOKEN_PROPERTY_NAME = 'support.type.property-name.json';\n    exports.TOKEN_COMMENT_BLOCK = 'comment.block.json';\n    exports.TOKEN_COMMENT_LINE = 'comment.line.json';\n});\n\ndefine(__m[3], __M([7,9]), function(nls, data) { return nls.create(\"vs/base/common/json\", data); });\ndefine(__m[4], __M([1,0,3]), function (require, exports, nls_1) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    (function (ScanError) {\n        ScanError[ScanError[\"None\"] = 0] = \"None\";\n        ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n        ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n        ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n        ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n        ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n    })(exports.ScanError || (exports.ScanError = {}));\n    var ScanError = exports.ScanError;\n    (function (SyntaxKind) {\n        SyntaxKind[SyntaxKind[\"Unknown\"] = 0] = \"Unknown\";\n        SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n        SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n        SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n        SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n        SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\n        SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\n        SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\n        SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n        SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n        SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\n        SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n        SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n        SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n        SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n        SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\n        SyntaxKind[SyntaxKind[\"EOF\"] = 16] = \"EOF\";\n    })(exports.SyntaxKind || (exports.SyntaxKind = {}));\n    var SyntaxKind = exports.SyntaxKind;\n    /**\n     * Creates a JSON scanner on the given text.\n     * If ignoreTrivia is set, whitespaces or comments are ignored.\n     */\n    function createScanner(text, ignoreTrivia) {\n        if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;\n        function scanHexDigits(count, exact) {\n            var digits = 0;\n            var value = 0;\n            while (digits < count || !exact) {\n                var ch = text.charCodeAt(pos);\n                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n                    value = value * 16 + ch - CharacterCodes._0;\n                }\n                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n                    value = value * 16 + ch - CharacterCodes.A + 10;\n                }\n                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n                    value = value * 16 + ch - CharacterCodes.a + 10;\n                }\n                else {\n                    break;\n                }\n                pos++;\n                digits++;\n            }\n            if (digits < count) {\n                value = -1;\n            }\n            return value;\n        }\n        function setPosition(newPosition) {\n            pos = newPosition;\n            value = '';\n            tokenOffset = 0;\n            token = SyntaxKind.Unknown;\n            scanError = ScanError.None;\n        }\n        function scanNumber() {\n            var start = pos;\n            if (text.charCodeAt(pos) === CharacterCodes._0) {\n                pos++;\n            }\n            else {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n                pos++;\n                if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                        pos++;\n                    }\n                }\n                else {\n                    scanError = ScanError.UnexpectedEndOfNumber;\n                    return text.substring(start, pos);\n                }\n            }\n            var end = pos;\n            if (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n                pos++;\n                if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n                    pos++;\n                }\n                if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                        pos++;\n                    }\n                    end = pos;\n                }\n                else {\n                    scanError = ScanError.UnexpectedEndOfNumber;\n                }\n            }\n            return text.substring(start, end);\n        }\n        function scanString() {\n            var result = '', start = pos;\n            while (true) {\n                if (pos >= len) {\n                    result += text.substring(start, pos);\n                    scanError = ScanError.UnexpectedEndOfString;\n                    break;\n                }\n                var ch = text.charCodeAt(pos);\n                if (ch === CharacterCodes.doubleQuote) {\n                    result += text.substring(start, pos);\n                    pos++;\n                    break;\n                }\n                if (ch === CharacterCodes.backslash) {\n                    result += text.substring(start, pos);\n                    pos++;\n                    if (pos >= len) {\n                        scanError = ScanError.UnexpectedEndOfString;\n                        break;\n                    }\n                    ch = text.charCodeAt(pos++);\n                    switch (ch) {\n                        case CharacterCodes.doubleQuote:\n                            result += '\\\"';\n                            break;\n                        case CharacterCodes.backslash:\n                            result += '\\\\';\n                            break;\n                        case CharacterCodes.slash:\n                            result += '/';\n                            break;\n                        case CharacterCodes.b:\n                            result += '\\b';\n                            break;\n                        case CharacterCodes.f:\n                            result += '\\f';\n                            break;\n                        case CharacterCodes.n:\n                            result += '\\n';\n                            break;\n                        case CharacterCodes.r:\n                            result += '\\r';\n                            break;\n                        case CharacterCodes.t:\n                            result += '\\t';\n                            break;\n                        case CharacterCodes.u:\n                            var ch_1 = scanHexDigits(4, true);\n                            if (ch_1 >= 0) {\n                                result += String.fromCharCode(ch_1);\n                            }\n                            else {\n                                scanError = ScanError.InvalidUnicode;\n                            }\n                            break;\n                        default:\n                            scanError = ScanError.InvalidEscapeCharacter;\n                    }\n                    start = pos;\n                    continue;\n                }\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    scanError = ScanError.UnexpectedEndOfString;\n                    break;\n                }\n                pos++;\n            }\n            return result;\n        }\n        function scanNext() {\n            value = '';\n            scanError = ScanError.None;\n            tokenOffset = pos;\n            if (pos >= len) {\n                // at the end\n                tokenOffset = len;\n                return token = SyntaxKind.EOF;\n            }\n            var code = text.charCodeAt(pos);\n            // trivia: whitespace\n            if (isWhiteSpace(code)) {\n                do {\n                    pos++;\n                    value += String.fromCharCode(code);\n                    code = text.charCodeAt(pos);\n                } while (isWhiteSpace(code));\n                return token = SyntaxKind.Trivia;\n            }\n            // trivia: newlines\n            if (isLineBreak(code)) {\n                pos++;\n                value += String.fromCharCode(code);\n                if (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n                    pos++;\n                    value += '\\n';\n                }\n                return token = SyntaxKind.LineBreakTrivia;\n            }\n            switch (code) {\n                // tokens: []{}:,\n                case CharacterCodes.openBrace:\n                    pos++;\n                    return token = SyntaxKind.OpenBraceToken;\n                case CharacterCodes.closeBrace:\n                    pos++;\n                    return token = SyntaxKind.CloseBraceToken;\n                case CharacterCodes.openBracket:\n                    pos++;\n                    return token = SyntaxKind.OpenBracketToken;\n                case CharacterCodes.closeBracket:\n                    pos++;\n                    return token = SyntaxKind.CloseBracketToken;\n                case CharacterCodes.colon:\n                    pos++;\n                    return token = SyntaxKind.ColonToken;\n                case CharacterCodes.comma:\n                    pos++;\n                    return token = SyntaxKind.CommaToken;\n                // strings\n                case CharacterCodes.doubleQuote:\n                    pos++;\n                    value = scanString();\n                    return token = SyntaxKind.StringLiteral;\n                // comments\n                case CharacterCodes.slash:\n                    var start = pos - 1;\n                    // Single-line comment\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n                        pos += 2;\n                        while (pos < len) {\n                            if (isLineBreak(text.charCodeAt(pos))) {\n                                break;\n                            }\n                            pos++;\n                        }\n                        value = text.substring(start, pos);\n                        return token = SyntaxKind.LineCommentTrivia;\n                    }\n                    // Multi-line comment\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n                        pos += 2;\n                        var safeLength = len - 1; // For lookahead.\n                        var commentClosed = false;\n                        while (pos < safeLength) {\n                            var ch = text.charCodeAt(pos);\n                            if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n                                pos += 2;\n                                commentClosed = true;\n                                break;\n                            }\n                            pos++;\n                        }\n                        if (!commentClosed) {\n                            pos++;\n                            scanError = ScanError.UnexpectedEndOfComment;\n                        }\n                        value = text.substring(start, pos);\n                        return token = SyntaxKind.BlockCommentTrivia;\n                    }\n                    // just a single slash\n                    value += String.fromCharCode(code);\n                    pos++;\n                    return token = SyntaxKind.Unknown;\n                // numbers\n                case CharacterCodes.minus:\n                    value += String.fromCharCode(code);\n                    pos++;\n                    if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                        return token = SyntaxKind.Unknown;\n                    }\n                // found a minus, followed by a number so\n                // we fall through to proceed with scanning\n                // numbers\n                case CharacterCodes._0:\n                case CharacterCodes._1:\n                case CharacterCodes._2:\n                case CharacterCodes._3:\n                case CharacterCodes._4:\n                case CharacterCodes._5:\n                case CharacterCodes._6:\n                case CharacterCodes._7:\n                case CharacterCodes._8:\n                case CharacterCodes._9:\n                    value += scanNumber();\n                    return token = SyntaxKind.NumericLiteral;\n                // literals and unknown symbols\n                default:\n                    // is a literal? Read the full word.\n                    while (pos < len && isUnknownContentCharacter(code)) {\n                        pos++;\n                        code = text.charCodeAt(pos);\n                    }\n                    if (tokenOffset !== pos) {\n                        value = text.substring(tokenOffset, pos);\n                        // keywords: true, false, null\n                        switch (value) {\n                            case 'true': return token = SyntaxKind.TrueKeyword;\n                            case 'false': return token = SyntaxKind.FalseKeyword;\n                            case 'null': return token = SyntaxKind.NullKeyword;\n                        }\n                        return token = SyntaxKind.Unknown;\n                    }\n                    // some\n                    value += String.fromCharCode(code);\n                    pos++;\n                    return token = SyntaxKind.Unknown;\n            }\n        }\n        function isUnknownContentCharacter(code) {\n            if (isWhiteSpace(code) || isLineBreak(code)) {\n                return false;\n            }\n            switch (code) {\n                case CharacterCodes.closeBrace:\n                case CharacterCodes.closeBracket:\n                case CharacterCodes.openBrace:\n                case CharacterCodes.openBracket:\n                case CharacterCodes.doubleQuote:\n                case CharacterCodes.colon:\n                case CharacterCodes.comma:\n                    return false;\n            }\n            return true;\n        }\n        function scanNextNonTrivia() {\n            var result;\n            do {\n                result = scanNext();\n            } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n            return result;\n        }\n        return {\n            setPosition: setPosition,\n            getPosition: function () { return pos; },\n            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n            getToken: function () { return token; },\n            getTokenValue: function () { return value; },\n            getTokenOffset: function () { return tokenOffset; },\n            getTokenLength: function () { return pos - tokenOffset; },\n            getTokenError: function () { return scanError; }\n        };\n    }\n    exports.createScanner = createScanner;\n    function isWhiteSpace(ch) {\n        return ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n            ch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n            ch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n    }\n    function isLineBreak(ch) {\n        return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n    }\n    function isDigit(ch) {\n        return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n    }\n    var CharacterCodes;\n    (function (CharacterCodes) {\n        CharacterCodes[CharacterCodes[\"nullCharacter\"] = 0] = \"nullCharacter\";\n        CharacterCodes[CharacterCodes[\"maxAsciiCharacter\"] = 127] = \"maxAsciiCharacter\";\n        CharacterCodes[CharacterCodes[\"lineFeed\"] = 10] = \"lineFeed\";\n        CharacterCodes[CharacterCodes[\"carriageReturn\"] = 13] = \"carriageReturn\";\n        CharacterCodes[CharacterCodes[\"lineSeparator\"] = 8232] = \"lineSeparator\";\n        CharacterCodes[CharacterCodes[\"paragraphSeparator\"] = 8233] = \"paragraphSeparator\";\n        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n        // like an odd disparity?  (Or maybe it's completely fine for them to be different).\n        CharacterCodes[CharacterCodes[\"nextLine\"] = 133] = \"nextLine\";\n        // Unicode 3.0 space characters\n        CharacterCodes[CharacterCodes[\"space\"] = 32] = \"space\";\n        CharacterCodes[CharacterCodes[\"nonBreakingSpace\"] = 160] = \"nonBreakingSpace\";\n        CharacterCodes[CharacterCodes[\"enQuad\"] = 8192] = \"enQuad\";\n        CharacterCodes[CharacterCodes[\"emQuad\"] = 8193] = \"emQuad\";\n        CharacterCodes[CharacterCodes[\"enSpace\"] = 8194] = \"enSpace\";\n        CharacterCodes[CharacterCodes[\"emSpace\"] = 8195] = \"emSpace\";\n        CharacterCodes[CharacterCodes[\"threePerEmSpace\"] = 8196] = \"threePerEmSpace\";\n        CharacterCodes[CharacterCodes[\"fourPerEmSpace\"] = 8197] = \"fourPerEmSpace\";\n        CharacterCodes[CharacterCodes[\"sixPerEmSpace\"] = 8198] = \"sixPerEmSpace\";\n        CharacterCodes[CharacterCodes[\"figureSpace\"] = 8199] = \"figureSpace\";\n        CharacterCodes[CharacterCodes[\"punctuationSpace\"] = 8200] = \"punctuationSpace\";\n        CharacterCodes[CharacterCodes[\"thinSpace\"] = 8201] = \"thinSpace\";\n        CharacterCodes[CharacterCodes[\"hairSpace\"] = 8202] = \"hairSpace\";\n        CharacterCodes[CharacterCodes[\"zeroWidthSpace\"] = 8203] = \"zeroWidthSpace\";\n        CharacterCodes[CharacterCodes[\"narrowNoBreakSpace\"] = 8239] = \"narrowNoBreakSpace\";\n        CharacterCodes[CharacterCodes[\"ideographicSpace\"] = 12288] = \"ideographicSpace\";\n        CharacterCodes[CharacterCodes[\"mathematicalSpace\"] = 8287] = \"mathematicalSpace\";\n        CharacterCodes[CharacterCodes[\"ogham\"] = 5760] = \"ogham\";\n        CharacterCodes[CharacterCodes[\"_\"] = 95] = \"_\";\n        CharacterCodes[CharacterCodes[\"$\"] = 36] = \"$\";\n        CharacterCodes[CharacterCodes[\"_0\"] = 48] = \"_0\";\n        CharacterCodes[CharacterCodes[\"_1\"] = 49] = \"_1\";\n        CharacterCodes[CharacterCodes[\"_2\"] = 50] = \"_2\";\n        CharacterCodes[CharacterCodes[\"_3\"] = 51] = \"_3\";\n        CharacterCodes[CharacterCodes[\"_4\"] = 52] = \"_4\";\n        CharacterCodes[CharacterCodes[\"_5\"] = 53] = \"_5\";\n        CharacterCodes[CharacterCodes[\"_6\"] = 54] = \"_6\";\n        CharacterCodes[CharacterCodes[\"_7\"] = 55] = \"_7\";\n        CharacterCodes[CharacterCodes[\"_8\"] = 56] = \"_8\";\n        CharacterCodes[CharacterCodes[\"_9\"] = 57] = \"_9\";\n        CharacterCodes[CharacterCodes[\"a\"] = 97] = \"a\";\n        CharacterCodes[CharacterCodes[\"b\"] = 98] = \"b\";\n        CharacterCodes[CharacterCodes[\"c\"] = 99] = \"c\";\n        CharacterCodes[CharacterCodes[\"d\"] = 100] = \"d\";\n        CharacterCodes[CharacterCodes[\"e\"] = 101] = \"e\";\n        CharacterCodes[CharacterCodes[\"f\"] = 102] = \"f\";\n        CharacterCodes[CharacterCodes[\"g\"] = 103] = \"g\";\n        CharacterCodes[CharacterCodes[\"h\"] = 104] = \"h\";\n        CharacterCodes[CharacterCodes[\"i\"] = 105] = \"i\";\n        CharacterCodes[CharacterCodes[\"j\"] = 106] = \"j\";\n        CharacterCodes[CharacterCodes[\"k\"] = 107] = \"k\";\n        CharacterCodes[CharacterCodes[\"l\"] = 108] = \"l\";\n        CharacterCodes[CharacterCodes[\"m\"] = 109] = \"m\";\n        CharacterCodes[CharacterCodes[\"n\"] = 110] = \"n\";\n        CharacterCodes[CharacterCodes[\"o\"] = 111] = \"o\";\n        CharacterCodes[CharacterCodes[\"p\"] = 112] = \"p\";\n        CharacterCodes[CharacterCodes[\"q\"] = 113] = \"q\";\n        CharacterCodes[CharacterCodes[\"r\"] = 114] = \"r\";\n        CharacterCodes[CharacterCodes[\"s\"] = 115] = \"s\";\n        CharacterCodes[CharacterCodes[\"t\"] = 116] = \"t\";\n        CharacterCodes[CharacterCodes[\"u\"] = 117] = \"u\";\n        CharacterCodes[CharacterCodes[\"v\"] = 118] = \"v\";\n        CharacterCodes[CharacterCodes[\"w\"] = 119] = \"w\";\n        CharacterCodes[CharacterCodes[\"x\"] = 120] = \"x\";\n        CharacterCodes[CharacterCodes[\"y\"] = 121] = \"y\";\n        CharacterCodes[CharacterCodes[\"z\"] = 122] = \"z\";\n        CharacterCodes[CharacterCodes[\"A\"] = 65] = \"A\";\n        CharacterCodes[CharacterCodes[\"B\"] = 66] = \"B\";\n        CharacterCodes[CharacterCodes[\"C\"] = 67] = \"C\";\n        CharacterCodes[CharacterCodes[\"D\"] = 68] = \"D\";\n        CharacterCodes[CharacterCodes[\"E\"] = 69] = \"E\";\n        CharacterCodes[CharacterCodes[\"F\"] = 70] = \"F\";\n        CharacterCodes[CharacterCodes[\"G\"] = 71] = \"G\";\n        CharacterCodes[CharacterCodes[\"H\"] = 72] = \"H\";\n        CharacterCodes[CharacterCodes[\"I\"] = 73] = \"I\";\n        CharacterCodes[CharacterCodes[\"J\"] = 74] = \"J\";\n        CharacterCodes[CharacterCodes[\"K\"] = 75] = \"K\";\n        CharacterCodes[CharacterCodes[\"L\"] = 76] = \"L\";\n        CharacterCodes[CharacterCodes[\"M\"] = 77] = \"M\";\n        CharacterCodes[CharacterCodes[\"N\"] = 78] = \"N\";\n        CharacterCodes[CharacterCodes[\"O\"] = 79] = \"O\";\n        CharacterCodes[CharacterCodes[\"P\"] = 80] = \"P\";\n        CharacterCodes[CharacterCodes[\"Q\"] = 81] = \"Q\";\n        CharacterCodes[CharacterCodes[\"R\"] = 82] = \"R\";\n        CharacterCodes[CharacterCodes[\"S\"] = 83] = \"S\";\n        CharacterCodes[CharacterCodes[\"T\"] = 84] = \"T\";\n        CharacterCodes[CharacterCodes[\"U\"] = 85] = \"U\";\n        CharacterCodes[CharacterCodes[\"V\"] = 86] = \"V\";\n        CharacterCodes[CharacterCodes[\"W\"] = 87] = \"W\";\n        CharacterCodes[CharacterCodes[\"X\"] = 88] = \"X\";\n        CharacterCodes[CharacterCodes[\"Y\"] = 89] = \"Y\";\n        CharacterCodes[CharacterCodes[\"Z\"] = 90] = \"Z\";\n        CharacterCodes[CharacterCodes[\"ampersand\"] = 38] = \"ampersand\";\n        CharacterCodes[CharacterCodes[\"asterisk\"] = 42] = \"asterisk\";\n        CharacterCodes[CharacterCodes[\"at\"] = 64] = \"at\";\n        CharacterCodes[CharacterCodes[\"backslash\"] = 92] = \"backslash\";\n        CharacterCodes[CharacterCodes[\"bar\"] = 124] = \"bar\";\n        CharacterCodes[CharacterCodes[\"caret\"] = 94] = \"caret\";\n        CharacterCodes[CharacterCodes[\"closeBrace\"] = 125] = \"closeBrace\";\n        CharacterCodes[CharacterCodes[\"closeBracket\"] = 93] = \"closeBracket\";\n        CharacterCodes[CharacterCodes[\"closeParen\"] = 41] = \"closeParen\";\n        CharacterCodes[CharacterCodes[\"colon\"] = 58] = \"colon\";\n        CharacterCodes[CharacterCodes[\"comma\"] = 44] = \"comma\";\n        CharacterCodes[CharacterCodes[\"dot\"] = 46] = \"dot\";\n        CharacterCodes[CharacterCodes[\"doubleQuote\"] = 34] = \"doubleQuote\";\n        CharacterCodes[CharacterCodes[\"equals\"] = 61] = \"equals\";\n        CharacterCodes[CharacterCodes[\"exclamation\"] = 33] = \"exclamation\";\n        CharacterCodes[CharacterCodes[\"greaterThan\"] = 62] = \"greaterThan\";\n        CharacterCodes[CharacterCodes[\"lessThan\"] = 60] = \"lessThan\";\n        CharacterCodes[CharacterCodes[\"minus\"] = 45] = \"minus\";\n        CharacterCodes[CharacterCodes[\"openBrace\"] = 123] = \"openBrace\";\n        CharacterCodes[CharacterCodes[\"openBracket\"] = 91] = \"openBracket\";\n        CharacterCodes[CharacterCodes[\"openParen\"] = 40] = \"openParen\";\n        CharacterCodes[CharacterCodes[\"percent\"] = 37] = \"percent\";\n        CharacterCodes[CharacterCodes[\"plus\"] = 43] = \"plus\";\n        CharacterCodes[CharacterCodes[\"question\"] = 63] = \"question\";\n        CharacterCodes[CharacterCodes[\"semicolon\"] = 59] = \"semicolon\";\n        CharacterCodes[CharacterCodes[\"singleQuote\"] = 39] = \"singleQuote\";\n        CharacterCodes[CharacterCodes[\"slash\"] = 47] = \"slash\";\n        CharacterCodes[CharacterCodes[\"tilde\"] = 126] = \"tilde\";\n        CharacterCodes[CharacterCodes[\"backspace\"] = 8] = \"backspace\";\n        CharacterCodes[CharacterCodes[\"formFeed\"] = 12] = \"formFeed\";\n        CharacterCodes[CharacterCodes[\"byteOrderMark\"] = 65279] = \"byteOrderMark\";\n        CharacterCodes[CharacterCodes[\"tab\"] = 9] = \"tab\";\n        CharacterCodes[CharacterCodes[\"verticalTab\"] = 11] = \"verticalTab\";\n    })(CharacterCodes || (CharacterCodes = {}));\n    /**\n     * Takes JSON with JavaScript-style comments and remove\n     * them. Optionally replaces every none-newline character\n     * of comments with a replaceCharacter\n     */\n    function stripComments(text, replaceCh) {\n        var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n        do {\n            pos = _scanner.getPosition();\n            kind = _scanner.scan();\n            switch (kind) {\n                case SyntaxKind.LineCommentTrivia:\n                case SyntaxKind.BlockCommentTrivia:\n                case SyntaxKind.EOF:\n                    if (offset !== pos) {\n                        parts.push(text.substring(offset, pos));\n                    }\n                    if (replaceCh !== void 0) {\n                        parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                    }\n                    offset = _scanner.getPosition();\n                    break;\n            }\n        } while (kind !== SyntaxKind.EOF);\n        return parts.join('');\n    }\n    exports.stripComments = stripComments;\n    (function (ParseErrorCode) {\n        ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 0] = \"InvalidSymbol\";\n        ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 1] = \"InvalidNumberFormat\";\n        ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 2] = \"PropertyNameExpected\";\n        ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 3] = \"ValueExpected\";\n        ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 4] = \"ColonExpected\";\n        ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 5] = \"CommaExpected\";\n        ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 6] = \"CloseBraceExpected\";\n        ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 7] = \"CloseBracketExpected\";\n        ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 8] = \"EndOfFileExpected\";\n    })(exports.ParseErrorCode || (exports.ParseErrorCode = {}));\n    var ParseErrorCode = exports.ParseErrorCode;\n    function getParseErrorMessage(errorCode) {\n        switch (errorCode) {\n            case ParseErrorCode.InvalidSymbol: return nls_1.localize(0, null);\n            case ParseErrorCode.InvalidNumberFormat: return nls_1.localize(1, null);\n            case ParseErrorCode.PropertyNameExpected: return nls_1.localize(2, null);\n            case ParseErrorCode.ValueExpected: return nls_1.localize(3, null);\n            case ParseErrorCode.ColonExpected: return nls_1.localize(4, null);\n            case ParseErrorCode.CommaExpected: return nls_1.localize(5, null);\n            case ParseErrorCode.CloseBraceExpected: return nls_1.localize(6, null);\n            case ParseErrorCode.CloseBracketExpected: return nls_1.localize(7, null);\n            case ParseErrorCode.EndOfFileExpected: return nls_1.localize(8, null);\n            default:\n                return '';\n        }\n    }\n    exports.getParseErrorMessage = getParseErrorMessage;\n    function getLiteralNodeType(value) {\n        switch (typeof value) {\n            case 'boolean': return 'boolean';\n            case 'number': return 'number';\n            case 'string': return 'string';\n            default: return 'null';\n        }\n    }\n    /**\n     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n     */\n    function getLocation(text, position) {\n        var segments = []; // strings or numbers\n        var earlyReturnException = new Object();\n        var previousNode = void 0;\n        var previousNodeInst = {\n            value: void 0,\n            offset: void 0,\n            length: void 0,\n            type: void 0\n        };\n        var isAtPropertyKey = false;\n        function setPreviousNode(value, offset, length, type) {\n            previousNodeInst.value = value;\n            previousNodeInst.offset = offset;\n            previousNodeInst.length = length;\n            previousNodeInst.type = type;\n            previousNodeInst.columnOffset = void 0;\n            previousNode = previousNodeInst;\n        }\n        try {\n            visit(text, {\n                onObjectBegin: function (offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = void 0;\n                    isAtPropertyKey = position > offset;\n                    segments.push(''); // push a placeholder (will be replaced or removed)\n                },\n                onObjectProperty: function (name, offset, length) {\n                    if (position < offset) {\n                        throw earlyReturnException;\n                    }\n                    setPreviousNode(name, offset, length, 'property');\n                    segments[segments.length - 1] = name;\n                    if (position <= offset + length) {\n                        throw earlyReturnException;\n                    }\n                },\n                onObjectEnd: function (offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = void 0;\n                    segments.pop();\n                },\n                onArrayBegin: function (offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = void 0;\n                    segments.push(0);\n                },\n                onArrayEnd: function (offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = void 0;\n                    segments.pop();\n                },\n                onLiteralValue: function (value, offset, length) {\n                    if (position < offset) {\n                        throw earlyReturnException;\n                    }\n                    setPreviousNode(value, offset, length, getLiteralNodeType(value));\n                    if (position <= offset + length) {\n                        throw earlyReturnException;\n                    }\n                },\n                onSeparator: function (sep, offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    if (sep === ':' && previousNode.type === 'property') {\n                        previousNode.columnOffset = offset;\n                        isAtPropertyKey = false;\n                        previousNode = void 0;\n                    }\n                    else if (sep === ',') {\n                        var last = segments[segments.length - 1];\n                        if (typeof last === 'number') {\n                            segments[segments.length - 1] = last + 1;\n                        }\n                        else {\n                            isAtPropertyKey = true;\n                            segments[segments.length - 1] = '';\n                        }\n                        previousNode = void 0;\n                    }\n                }\n            });\n        }\n        catch (e) {\n            if (e !== earlyReturnException) {\n                throw e;\n            }\n        }\n        if (segments[segments.length - 1] === '') {\n            segments.pop();\n        }\n        return {\n            path: segments,\n            previousNode: previousNode,\n            isAtPropertyKey: isAtPropertyKey,\n            matches: function (pattern) {\n                var k = 0;\n                for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                    if (pattern[k] === segments[i] || pattern[k] === '*') {\n                        k++;\n                    }\n                    else if (pattern[k] !== '**') {\n                        return false;\n                    }\n                }\n                return k === pattern.length;\n            }\n        };\n    }\n    exports.getLocation = getLocation;\n    /**\n     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n     * Therefore always check the errors list to find out if the input was valid.\n     */\n    function parse(text, errors, options) {\n        if (errors === void 0) { errors = []; }\n        var currentProperty = null;\n        var currentParent = [];\n        var previousParents = [];\n        function onValue(value) {\n            if (Array.isArray(currentParent)) {\n                currentParent.push(value);\n            }\n            else if (currentProperty) {\n                currentParent[currentProperty] = value;\n            }\n        }\n        var visitor = {\n            onObjectBegin: function () {\n                var object = {};\n                onValue(object);\n                previousParents.push(currentParent);\n                currentParent = object;\n                currentProperty = null;\n            },\n            onObjectProperty: function (name) {\n                currentProperty = name;\n            },\n            onObjectEnd: function () {\n                currentParent = previousParents.pop();\n            },\n            onArrayBegin: function () {\n                var array = [];\n                onValue(array);\n                previousParents.push(currentParent);\n                currentParent = array;\n                currentProperty = null;\n            },\n            onArrayEnd: function () {\n                currentParent = previousParents.pop();\n            },\n            onLiteralValue: onValue,\n            onError: function (error) {\n                errors.push({ error: error });\n            }\n        };\n        visit(text, visitor, options);\n        return currentParent[0];\n    }\n    exports.parse = parse;\n    /**\n     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n     */\n    function parseTree(text, errors, options) {\n        if (errors === void 0) { errors = []; }\n        var currentParent = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root\n        function ensurePropertyComplete(endOffset) {\n            if (currentParent.type === 'property') {\n                currentParent.length = endOffset - currentParent.offset;\n                currentParent = currentParent.parent;\n            }\n        }\n        function onValue(valueNode) {\n            currentParent.children.push(valueNode);\n            ensurePropertyComplete(valueNode.offset + valueNode.length);\n            return valueNode;\n        }\n        var visitor = {\n            onObjectBegin: function (offset) {\n                currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n            },\n            onObjectProperty: function (name, offset, length) {\n                currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n                currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n            },\n            onObjectEnd: function (offset, length) {\n                ensurePropertyComplete(offset);\n                currentParent.length = offset + length - currentParent.offset;\n                currentParent = currentParent.parent;\n            },\n            onArrayBegin: function (offset, length) {\n                currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n            },\n            onArrayEnd: function (offset, length) {\n                currentParent.length = offset + length - currentParent.offset;\n                currentParent = currentParent.parent;\n            },\n            onLiteralValue: function (value, offset, length) {\n                onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n            },\n            onSeparator: function (sep, offset, length) {\n                if (currentParent.type === 'property') {\n                    if (sep === ':') {\n                        currentParent.columnOffset = offset;\n                    }\n                    else if (sep === ',') {\n                        ensurePropertyComplete(offset);\n                    }\n                }\n            },\n            onError: function (error) {\n                errors.push({ error: error });\n            }\n        };\n        visit(text, visitor, options);\n        var result = currentParent.children[0];\n        if (result) {\n            delete result.parent;\n        }\n        return result;\n    }\n    exports.parseTree = parseTree;\n    function findNodeAtLocation(root, path) {\n        if (!root) {\n            return void 0;\n        }\n        var node = root;\n        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n            var segment = path_1[_i];\n            if (typeof segment === 'string') {\n                if (node.type !== 'object') {\n                    return void 0;\n                }\n                var found = false;\n                for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                    var propertyNode = _b[_a];\n                    if (propertyNode.children[0].value === segment) {\n                        node = propertyNode.children[1];\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return void 0;\n                }\n            }\n            else {\n                var index = segment;\n                if (node.type !== 'array' || index < 0 || index >= node.children.length) {\n                    return void 0;\n                }\n                node = node.children[index];\n            }\n        }\n        return node;\n    }\n    exports.findNodeAtLocation = findNodeAtLocation;\n    function getNodeValue(node) {\n        if (node.type === 'array') {\n            return node.children.map(getNodeValue);\n        }\n        else if (node.type === 'object') {\n            var obj = {};\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                var prop = _a[_i];\n                obj[prop.children[0].value] = getNodeValue(prop.children[1]);\n            }\n            return obj;\n        }\n        return node.value;\n    }\n    exports.getNodeValue = getNodeValue;\n    /**\n     * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n     */\n    function visit(text, visitor, options) {\n        var _scanner = createScanner(text, false);\n        function toNoArgVisit(visitFunction) {\n            return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\n        }\n        function toOneArgVisit(visitFunction) {\n            return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\n        }\n        var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onError = toOneArgVisit(visitor.onError);\n        var disallowComments = options && options.disallowComments;\n        function scanNext() {\n            while (true) {\n                var token = _scanner.scan();\n                switch (token) {\n                    case SyntaxKind.LineCommentTrivia:\n                    case SyntaxKind.BlockCommentTrivia:\n                        if (disallowComments) {\n                            handleError(ParseErrorCode.InvalidSymbol);\n                        }\n                        break;\n                    case SyntaxKind.Unknown:\n                        handleError(ParseErrorCode.InvalidSymbol);\n                        break;\n                    case SyntaxKind.Trivia:\n                    case SyntaxKind.LineBreakTrivia:\n                        break;\n                    default:\n                        return token;\n                }\n            }\n        }\n        function handleError(error, skipUntilAfter, skipUntil) {\n            if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n            if (skipUntil === void 0) { skipUntil = []; }\n            onError(error);\n            if (skipUntilAfter.length + skipUntil.length > 0) {\n                var token = _scanner.getToken();\n                while (token !== SyntaxKind.EOF) {\n                    if (skipUntilAfter.indexOf(token) !== -1) {\n                        scanNext();\n                        break;\n                    }\n                    else if (skipUntil.indexOf(token) !== -1) {\n                        break;\n                    }\n                    token = scanNext();\n                }\n            }\n        }\n        function parseString(isValue) {\n            if (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n                return false;\n            }\n            var value = _scanner.getTokenValue();\n            if (isValue) {\n                onLiteralValue(value);\n            }\n            else {\n                onObjectProperty(value);\n            }\n            scanNext();\n            return true;\n        }\n        function parseLiteral() {\n            switch (_scanner.getToken()) {\n                case SyntaxKind.NumericLiteral:\n                    var value = 0;\n                    try {\n                        value = JSON.parse(_scanner.getTokenValue());\n                        if (typeof value !== 'number') {\n                            handleError(ParseErrorCode.InvalidNumberFormat);\n                            value = 0;\n                        }\n                    }\n                    catch (e) {\n                        handleError(ParseErrorCode.InvalidNumberFormat);\n                    }\n                    onLiteralValue(value);\n                    break;\n                case SyntaxKind.NullKeyword:\n                    onLiteralValue(null);\n                    break;\n                case SyntaxKind.TrueKeyword:\n                    onLiteralValue(true);\n                    break;\n                case SyntaxKind.FalseKeyword:\n                    onLiteralValue(false);\n                    break;\n                default:\n                    return false;\n            }\n            scanNext();\n            return true;\n        }\n        function parseProperty() {\n            if (!parseString(false)) {\n                handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n                return false;\n            }\n            if (_scanner.getToken() === SyntaxKind.ColonToken) {\n                onSeparator(':');\n                scanNext(); // consume colon\n                if (!parseValue()) {\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n                }\n            }\n            else {\n                handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n            }\n            return true;\n        }\n        function parseObject() {\n            if (_scanner.getToken() !== SyntaxKind.OpenBraceToken) {\n                return false;\n            }\n            onObjectBegin();\n            scanNext(); // consume open brace\n            var needsComma = false;\n            while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n                if (_scanner.getToken() === SyntaxKind.CommaToken) {\n                    if (!needsComma) {\n                        handleError(ParseErrorCode.ValueExpected, [], []);\n                    }\n                    onSeparator(',');\n                    scanNext(); // consume comma\n                }\n                else if (needsComma) {\n                    handleError(ParseErrorCode.CommaExpected, [], []);\n                }\n                if (!parseProperty()) {\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\n                }\n                needsComma = true;\n            }\n            onObjectEnd();\n            if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n                handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n            }\n            else {\n                scanNext(); // consume close brace\n            }\n            return true;\n        }\n        function parseArray() {\n            if (_scanner.getToken() !== SyntaxKind.OpenBracketToken) {\n                return false;\n            }\n            onArrayBegin();\n            scanNext(); // consume open bracket\n            var needsComma = false;\n            while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n                if (_scanner.getToken() === SyntaxKind.CommaToken) {\n                    if (!needsComma) {\n                        handleError(ParseErrorCode.ValueExpected, [], []);\n                    }\n                    onSeparator(',');\n                    scanNext(); // consume comma\n                }\n                else if (needsComma) {\n                    handleError(ParseErrorCode.CommaExpected, [], []);\n                }\n                if (!parseValue()) {\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\n                }\n                needsComma = true;\n            }\n            onArrayEnd();\n            if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n                handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n            }\n            else {\n                scanNext(); // consume close bracket\n            }\n            return true;\n        }\n        function parseValue() {\n            return parseArray() || parseObject() || parseString(true) || parseLiteral();\n        }\n        scanNext();\n        if (_scanner.getToken() === SyntaxKind.EOF) {\n            return true;\n        }\n        if (!parseValue()) {\n            handleError(ParseErrorCode.ValueExpected, [], []);\n            return false;\n        }\n        if (_scanner.getToken() !== SyntaxKind.EOF) {\n            handleError(ParseErrorCode.EndOfFileExpected, [], []);\n        }\n        return true;\n    }\n    exports.visit = visit;\n});\n\ndefine(__m[5], __M([1,0,4,2]), function (require, exports, json, jsonTokenTypes) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    function createTokenizationSupport(mode, supportComments) {\n        return {\n            shouldGenerateEmbeddedModels: false,\n            getInitialState: function () { return new JSONState(mode, null, null, false); },\n            tokenize: function (line, state, offsetDelta, stopAtOffset) { return tokenize(mode, supportComments, line, state, offsetDelta, stopAtOffset); }\n        };\n    }\n    exports.createTokenizationSupport = createTokenizationSupport;\n    var JSONState = (function () {\n        function JSONState(mode, state, scanError, lastWasColon) {\n            this._mode = mode;\n            this._state = state;\n            this.scanError = scanError;\n            this.lastWasColon = lastWasColon;\n        }\n        JSONState.prototype.clone = function () {\n            return new JSONState(this._mode, this._state, this.scanError, this.lastWasColon);\n        };\n        JSONState.prototype.equals = function (other) {\n            if (other === this) {\n                return true;\n            }\n            if (!other || !(other instanceof JSONState)) {\n                return false;\n            }\n            return this.scanError === other.scanError &&\n                this.lastWasColon === other.lastWasColon;\n        };\n        JSONState.prototype.getMode = function () {\n            return this._mode;\n        };\n        JSONState.prototype.tokenize = function (stream) {\n            throw new Error();\n        };\n        JSONState.prototype.getStateData = function () {\n            return this._state;\n        };\n        JSONState.prototype.setStateData = function (state) {\n            this._state = state;\n        };\n        return JSONState;\n    }());\n    function tokenize(mode, comments, line, state, offsetDelta, stopAtOffset) {\n        if (offsetDelta === void 0) { offsetDelta = 0; }\n        // handle multiline strings and block comments\n        var numberOfInsertedCharacters = 0, adjustOffset = false;\n        switch (state.scanError) {\n            case json.ScanError.UnexpectedEndOfString:\n                line = '\"' + line;\n                numberOfInsertedCharacters = 1;\n                break;\n            case json.ScanError.UnexpectedEndOfComment:\n                line = '/*' + line;\n                numberOfInsertedCharacters = 2;\n                break;\n        }\n        var scanner = json.createScanner(line), kind, ret, lastWasColon = state.lastWasColon;\n        ret = {\n            tokens: [],\n            actualStopOffset: line.length,\n            endState: state.clone(),\n            modeTransitions: [{ startIndex: 0, mode: mode }],\n        };\n        while (true) {\n            var offset = offsetDelta + scanner.getPosition(), type = '';\n            kind = scanner.scan();\n            if (kind === json.SyntaxKind.EOF) {\n                break;\n            }\n            // Check that the scanner has advanced\n            if (offset === offsetDelta + scanner.getPosition()) {\n                throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\n            }\n            // In case we inserted /* or \" character, we need to\n            // adjust the offset of all tokens (except the first)\n            if (adjustOffset) {\n                offset -= numberOfInsertedCharacters;\n            }\n            adjustOffset = numberOfInsertedCharacters > 0;\n            // brackets and type\n            switch (kind) {\n                case json.SyntaxKind.OpenBraceToken:\n                    type = jsonTokenTypes.TOKEN_DELIM_OBJECT;\n                    lastWasColon = false;\n                    break;\n                case json.SyntaxKind.CloseBraceToken:\n                    type = jsonTokenTypes.TOKEN_DELIM_OBJECT;\n                    lastWasColon = false;\n                    break;\n                case json.SyntaxKind.OpenBracketToken:\n                    type = jsonTokenTypes.TOKEN_DELIM_ARRAY;\n                    lastWasColon = false;\n                    break;\n                case json.SyntaxKind.CloseBracketToken:\n                    type = jsonTokenTypes.TOKEN_DELIM_ARRAY;\n                    lastWasColon = false;\n                    break;\n                case json.SyntaxKind.ColonToken:\n                    type = jsonTokenTypes.TOKEN_DELIM_COLON;\n                    lastWasColon = true;\n                    break;\n                case json.SyntaxKind.CommaToken:\n                    type = jsonTokenTypes.TOKEN_DELIM_COMMA;\n                    lastWasColon = false;\n                    break;\n                case json.SyntaxKind.TrueKeyword:\n                case json.SyntaxKind.FalseKeyword:\n                    type = jsonTokenTypes.TOKEN_VALUE_BOOLEAN;\n                    lastWasColon = false;\n                    break;\n                case json.SyntaxKind.NullKeyword:\n                    type = jsonTokenTypes.TOKEN_VALUE_NULL;\n                    lastWasColon = false;\n                    break;\n                case json.SyntaxKind.StringLiteral:\n                    type = lastWasColon ? jsonTokenTypes.TOKEN_VALUE_STRING : jsonTokenTypes.TOKEN_PROPERTY_NAME;\n                    lastWasColon = false;\n                    break;\n                case json.SyntaxKind.NumericLiteral:\n                    type = jsonTokenTypes.TOKEN_VALUE_NUMBER;\n                    lastWasColon = false;\n                    break;\n            }\n            // comments, iff enabled\n            if (comments) {\n                switch (kind) {\n                    case json.SyntaxKind.LineCommentTrivia:\n                        type = jsonTokenTypes.TOKEN_COMMENT_LINE;\n                        break;\n                    case json.SyntaxKind.BlockCommentTrivia:\n                        type = jsonTokenTypes.TOKEN_COMMENT_BLOCK;\n                        break;\n                }\n            }\n            ret.endState = new JSONState(state.getMode(), state.getStateData(), scanner.getTokenError(), lastWasColon);\n            ret.tokens.push({\n                startIndex: offset,\n                type: type\n            });\n        }\n        return ret;\n    }\n});\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine(__m[8], __M([1,0,17,10,5,11,12,13,14,15,16,6]), function (require, exports, modes, Platform, tokenization, abstractMode_1, threadService_1, thread_1, jsonContributionRegistry_1, instantiation_1, languageConfigurationRegistry_1, async_1) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    var JSONMode = (function (_super) {\n        __extends(JSONMode, _super);\n        function JSONMode(descriptor, instantiationService, threadService) {\n            var _this = this;\n            _super.call(this, descriptor.id);\n            this._modeWorkerManager = new abstractMode_1.ModeWorkerManager(descriptor, 'vs/languages/json/common/jsonWorker', 'JSONWorker', null, instantiationService);\n            this._threadService = threadService;\n            this.tokenizationSupport = tokenization.createTokenizationSupport(this, true);\n            languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(this.getId(), JSONMode.LANG_CONFIG);\n            modes.HoverProviderRegistry.register(this.getId(), {\n                provideHover: function (model, position, token) {\n                    return async_1.wireCancellationToken(token, _this._provideHover(model.uri, position));\n                }\n            }, true);\n            this.inplaceReplaceSupport = this;\n            this.configSupport = this;\n            // Initialize Outline support\n            modes.DocumentSymbolProviderRegistry.register(this.getId(), {\n                provideDocumentSymbols: function (model, token) {\n                    return async_1.wireCancellationToken(token, _this._provideDocumentSymbols(model.uri));\n                }\n            }, true);\n            modes.DocumentFormattingEditProviderRegistry.register(this.getId(), {\n                provideDocumentFormattingEdits: function (model, options, token) {\n                    return async_1.wireCancellationToken(token, _this._provideDocumentFormattingEdits(model.uri, options));\n                }\n            }, true);\n            modes.DocumentRangeFormattingEditProviderRegistry.register(this.getId(), {\n                provideDocumentRangeFormattingEdits: function (model, range, options, token) {\n                    return async_1.wireCancellationToken(token, _this._provideDocumentRangeFormattingEdits(model.uri, range, options));\n                }\n            }, true);\n            modes.SuggestRegistry.register(this.getId(), {\n                triggerCharacters: [],\n                shouldAutotriggerSuggest: true,\n                provideCompletionItems: function (model, position, token) {\n                    return async_1.wireCancellationToken(token, _this._provideCompletionItems(model.uri, position));\n                }\n            }, true);\n        }\n        JSONMode.prototype.creationDone = function () {\n            var _this = this;\n            if (this._threadService.isInMainThread) {\n                // Pick a worker to do validation\n                this._pickAWorkerToValidate();\n                // Configure all workers\n                this._configureWorkerSchemas(this.getSchemaConfiguration());\n                var contributionRegistry = Platform.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);\n                contributionRegistry.addRegistryChangedListener(function (e) {\n                    _this._configureWorkerSchemas(_this.getSchemaConfiguration());\n                });\n            }\n        };\n        JSONMode.prototype._worker = function (runner) {\n            return this._modeWorkerManager.worker(runner);\n        };\n        JSONMode.prototype.getSchemaConfiguration = function () {\n            var contributionRegistry = Platform.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);\n            return contributionRegistry.getSchemaContributions();\n        };\n        JSONMode.prototype.configure = function (options) {\n            if (this._threadService.isInMainThread) {\n                return this._configureWorkers(options);\n            }\n            else {\n                return this._worker(function (w) { return w._doConfigure(options); });\n            }\n        };\n        JSONMode.prototype._configureWorkers = function (options) {\n            return this._worker(function (w) { return w._doConfigure(options); });\n        };\n        JSONMode.prototype._configureWorkerSchemas = function (data) {\n            return this._worker(function (w) { return w.setSchemaContributions(data); });\n        };\n        JSONMode.prototype._pickAWorkerToValidate = function () {\n            return this._worker(function (w) { return w.enableValidator(); });\n        };\n        JSONMode.prototype.navigateValueSet = function (resource, position, up) {\n            return this._worker(function (w) { return w.navigateValueSet(resource, position, up); });\n        };\n        JSONMode.prototype._provideCompletionItems = function (resource, position) {\n            return this._worker(function (w) { return w.provideCompletionItems(resource, position); });\n        };\n        JSONMode.prototype._provideHover = function (resource, position) {\n            return this._worker(function (w) { return w.provideHover(resource, position); });\n        };\n        JSONMode.prototype._provideDocumentSymbols = function (resource) {\n            return this._worker(function (w) { return w.provideDocumentSymbols(resource); });\n        };\n        JSONMode.prototype._provideDocumentFormattingEdits = function (resource, options) {\n            return this._worker(function (w) { return w.format(resource, null, options); });\n        };\n        JSONMode.prototype._provideDocumentRangeFormattingEdits = function (resource, range, options) {\n            return this._worker(function (w) { return w.format(resource, range, options); });\n        };\n        JSONMode.LANG_CONFIG = {\n            wordPattern: abstractMode_1.createWordRegExp('.-'),\n            comments: {\n                lineComment: '//',\n                blockComment: ['/*', '*/']\n            },\n            brackets: [\n                ['{', '}'],\n                ['[', ']']\n            ],\n            autoClosingPairs: [\n                { open: '{', close: '}', notIn: ['string'] },\n                { open: '[', close: ']', notIn: ['string'] },\n                { open: '\"', close: '\"', notIn: ['string'] }\n            ]\n        };\n        JSONMode.$_configureWorkers = threadService_1.AllWorkersAttr(JSONMode, JSONMode.prototype._configureWorkers);\n        JSONMode.$_configureWorkerSchemas = threadService_1.AllWorkersAttr(JSONMode, JSONMode.prototype._configureWorkerSchemas);\n        JSONMode.$_pickAWorkerToValidate = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._pickAWorkerToValidate, thread_1.ThreadAffinity.Group1);\n        JSONMode.$navigateValueSet = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype.navigateValueSet);\n        JSONMode.$_provideCompletionItems = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideCompletionItems);\n        JSONMode.$_provideHover = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideHover);\n        JSONMode.$_provideDocumentSymbols = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentSymbols);\n        JSONMode.$_provideDocumentFormattingEdits = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentFormattingEdits);\n        JSONMode.$_provideDocumentRangeFormattingEdits = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentRangeFormattingEdits);\n        JSONMode = __decorate([\n            __param(1, instantiation_1.IInstantiationService),\n            __param(2, thread_1.IThreadService)\n        ], JSONMode);\n        return JSONMode;\n    }(abstractMode_1.AbstractMode));\n    exports.JSONMode = JSONMode;\n});\n\n}).call(this);\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport const TOKEN_DELIM_OBJECT = 'punctuation.bracket.json';\nexport const TOKEN_DELIM_ARRAY = 'punctuation.array.json';\nexport const TOKEN_DELIM_COLON = 'punctuation.colon.json';\nexport const TOKEN_DELIM_COMMA = 'punctuation.comma.json';\nexport const TOKEN_VALUE_BOOLEAN= 'support.property-value.keyword.json';\nexport const TOKEN_VALUE_NULL= 'support.property-value.constant.other.json';\nexport const TOKEN_VALUE_STRING = 'support.property-value.string.value.json';\nexport const TOKEN_VALUE_NUMBER = 'support.property-value.constant.numeric.json';\nexport const TOKEN_PROPERTY_NAME = 'support.type.property-name.json';\nexport const TOKEN_COMMENT_BLOCK = 'comment.block.json';\nexport const TOKEN_COMMENT_LINE = 'comment.line.json';","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {localize} from 'vs/nls';\n\nexport enum ScanError {\n\tNone,\n\tUnexpectedEndOfComment,\n\tUnexpectedEndOfString,\n\tUnexpectedEndOfNumber,\n\tInvalidUnicode,\n\tInvalidEscapeCharacter\n}\n\nexport enum SyntaxKind {\n\tUnknown = 0,\n\tOpenBraceToken,\n\tCloseBraceToken,\n\tOpenBracketToken,\n\tCloseBracketToken,\n\tCommaToken,\n\tColonToken,\n\tNullKeyword,\n\tTrueKeyword,\n\tFalseKeyword,\n\tStringLiteral,\n\tNumericLiteral,\n\tLineCommentTrivia,\n\tBlockCommentTrivia,\n\tLineBreakTrivia,\n\tTrivia,\n\tEOF\n}\n\n/**\n * The scanner object, representing a JSON scanner at a position in the input string.\n */\nexport interface JSONScanner {\n\t/**\n\t * Sets the scan position to a new offset. A call to 'scan' is needed to get the first token.\n\t */\n\tsetPosition(pos: number);\n\t/**\n\t * Read the next token. Returns the tolen code.\n\t */\n\tscan(): SyntaxKind;\n\t/**\n\t * Returns the current scan position, which is after the last read token.\n\t */\n\tgetPosition(): number;\n\t/**\n\t * Returns the last read token.\n\t */\n\tgetToken(): SyntaxKind;\n\t/**\n\t * Returns the last read token value. The value for strings is the decoded string content. For numbers its of type number, for boolean it's true or false.\n\t */\n\tgetTokenValue(): string;\n\t/**\n\t * The start offset of the last read token.\n\t */\n\tgetTokenOffset(): number;\n\t/**\n\t * The length of the last read token.\n\t */\n\tgetTokenLength(): number;\n\t/**\n\t * An error code of the last scan.\n\t */\n\tgetTokenError(): ScanError;\n}\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text:string, ignoreTrivia:boolean = false):JSONScanner {\n\n\tlet pos = 0,\n\t\tlen = text.length,\n\t\tvalue:string = '',\n\t\ttokenOffset = 0,\n\t\ttoken:SyntaxKind = SyntaxKind.Unknown,\n\t\tscanError:ScanError = ScanError.None;\n\n\tfunction scanHexDigits(count: number, exact?: boolean): number {\n\t\tlet digits = 0;\n\t\tlet value = 0;\n\t\twhile (digits < count || !exact) {\n\t\t\tlet ch = text.charCodeAt(pos);\n\t\t\tif (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes._0;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes.A + 10;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes.a + 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t\tdigits++;\n\t\t}\n\t\tif (digits < count) {\n\t\t\tvalue = -1;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction setPosition(newPosition: number) {\n\t\tpos = newPosition;\n\t\tvalue = '';\n\t\ttokenOffset = 0;\n\t\ttoken = SyntaxKind.Unknown;\n\t\tscanError = ScanError.None;\n\t}\n\n\tfunction scanNumber(): string {\n\t\tlet start = pos;\n\t\tif (text.charCodeAt(pos) === CharacterCodes._0) {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos++;\n\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t\treturn text.substring(start, pos);\n\t\t\t}\n\t\t}\n\t\tlet end = pos;\n\t\tif (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tend = pos;\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t}\n\t\t}\n\t\treturn text.substring(start, end);\n\t}\n\n\tfunction scanString(): string {\n\n\t\tlet result = '',\n\t\t\tstart = pos;\n\n\t\twhile (true) {\n\t\t\tif (pos >= len) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlet ch = text.charCodeAt(pos);\n\t\t\tif (ch === CharacterCodes.doubleQuote) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch === CharacterCodes.backslash) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tif (pos >= len) {\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tch = text.charCodeAt(pos++);\n\t\t\t\tswitch (ch) {\n\t\t\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\t\t\tresult += '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.backslash:\n\t\t\t\t\t\tresult += '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.slash:\n\t\t\t\t\t\tresult += '/';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.b:\n\t\t\t\t\t\tresult += '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.f:\n\t\t\t\t\t\tresult += '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.n:\n\t\t\t\t\t\tresult += '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.r:\n\t\t\t\t\t\tresult += '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.t:\n\t\t\t\t\t\tresult += '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.u:\n\t\t\t\t\t\tlet ch = scanHexDigits(4, true);\n\t\t\t\t\t\tif (ch >= 0) {\n\t\t\t\t\t\t\tresult += String.fromCharCode(ch);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscanError = ScanError.InvalidUnicode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tscanError = ScanError.InvalidEscapeCharacter;\n\t\t\t\t}\n\t\t\t\tstart = pos;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isLineBreak(ch)) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction scanNext():SyntaxKind {\n\n\t\tvalue = '';\n\t\tscanError = ScanError.None;\n\n\t\ttokenOffset = pos;\n\n\t\tif(pos >= len) {\n\t\t\t// at the end\n\t\t\ttokenOffset = len;\n\t\t\treturn token = SyntaxKind.EOF;\n\t\t}\n\n\t\tlet code = text.charCodeAt(pos);\n\t\t// trivia: whitespace\n\t\tif (isWhiteSpace(code)) {\n\t\t\tdo {\n\t\t\t\tpos++;\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t} while (isWhiteSpace(code));\n\n\t\t\treturn token = SyntaxKind.Trivia;\n\t\t}\n\n\t\t// trivia: newlines\n\t\tif (isLineBreak(code)) {\n\t\t\tpos++;\n\t\t\tvalue += String.fromCharCode(code);\n\t\t\tif (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n\t\t\t\tpos++;\n\t\t\t\tvalue += '\\n';\n\t\t\t}\n\t\t\treturn token = SyntaxKind.LineBreakTrivia;\n\t\t}\n\n\t\tswitch(code) {\n\t\t\t// tokens: []{}:,\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBraceToken;\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBraceToken;\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBracketToken;\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBracketToken;\n\t\t\tcase CharacterCodes.colon:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.ColonToken;\n\t\t\tcase CharacterCodes.comma:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CommaToken;\n\n\t\t\t// strings\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\tpos++;\n\t\t\t\tvalue = scanString();\n\t\t\t\treturn token = SyntaxKind.StringLiteral;\n\n\t\t\t// comments\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\tlet start = pos - 1;\n\t\t\t\t// Single-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\twhile (pos < len) {\n\t\t\t\t\t\tif (isLineBreak(text.charCodeAt(pos))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\n\t\t\t\t\t}\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.LineCommentTrivia;\n\t\t\t\t}\n\n\t\t\t\t// Multi-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\tlet safeLength = len - 1; // For lookahead.\n\t\t\t\t\tlet commentClosed = false;\n\t\t\t\t\twhile (pos < safeLength) {\n\t\t\t\t\t\tlet ch = text.charCodeAt(pos);\n\n\t\t\t\t\t\tif (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\t\t\tpos += 2;\n\t\t\t\t\t\t\tcommentClosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!commentClosed) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tscanError = ScanError.UnexpectedEndOfComment;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.BlockCommentTrivia;\n\t\t\t\t}\n\t\t\t\t// just a single slash\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\n\t\t\t// numbers\n\t\t\tcase CharacterCodes.minus:\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\tif (pos === len || !isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t\t// found a minus, followed by a number so\n\t\t\t\t// we fall through to proceed with scanning\n\t\t\t\t// numbers\n\t\t\tcase CharacterCodes._0:\n\t\t\tcase CharacterCodes._1:\n\t\t\tcase CharacterCodes._2:\n\t\t\tcase CharacterCodes._3:\n\t\t\tcase CharacterCodes._4:\n\t\t\tcase CharacterCodes._5:\n\t\t\tcase CharacterCodes._6:\n\t\t\tcase CharacterCodes._7:\n\t\t\tcase CharacterCodes._8:\n\t\t\tcase CharacterCodes._9:\n\t\t\t\tvalue += scanNumber();\n\t\t\t\treturn token = SyntaxKind.NumericLiteral;\n\t\t\t// literals and unknown symbols\n\t\t\tdefault:\n\t\t\t\t// is a literal? Read the full word.\n\t\t\t\twhile (pos < len && isUnknownContentCharacter(code)) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t\t}\n\t\t\t\tif (tokenOffset !== pos) {\n\t\t\t\t\tvalue = text.substring(tokenOffset, pos);\n\t\t\t\t\t// keywords: true, false, null\n\t\t\t\t\tswitch (value) {\n\t\t\t\t\t\tcase 'true': return token = SyntaxKind.TrueKeyword;\n\t\t\t\t\t\tcase 'false': return token = SyntaxKind.FalseKeyword;\n\t\t\t\t\t\tcase 'null': return token = SyntaxKind.NullKeyword;\n\t\t\t\t\t}\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t\t// some\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t}\n\t}\n\n\tfunction isUnknownContentCharacter(code: CharacterCodes) {\n\t\tif (isWhiteSpace(code) || isLineBreak(code)) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (code) {\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\tcase CharacterCodes.colon:\n\t\t\tcase CharacterCodes.comma:\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tfunction scanNextNonTrivia():SyntaxKind {\n\t\tlet result : SyntaxKind;\n\t\tdo {\n\t\t\tresult = scanNext();\n\t\t} while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n\t\treturn result;\n\t}\n\n\treturn {\n\t\tsetPosition: setPosition,\n\t\tgetPosition: () => pos,\n\t\tscan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n\t\tgetToken: () => token,\n\t\tgetTokenValue: () => value,\n\t\tgetTokenOffset: () => tokenOffset,\n\t\tgetTokenLength: () => pos - tokenOffset,\n\t\tgetTokenError: () => scanError\n\t};\n}\n\nfunction isWhiteSpace(ch: number): boolean {\n\treturn ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n\t\tch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n\t\tch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n}\n\nfunction isLineBreak(ch: number): boolean {\n\treturn ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n}\n\nfunction isDigit(ch: number): boolean {\n\treturn ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n}\n\nenum CharacterCodes {\n\tnullCharacter = 0,\n\tmaxAsciiCharacter = 0x7F,\n\n\tlineFeed = 0x0A,              // \\n\n\tcarriageReturn = 0x0D,        // \\r\n\tlineSeparator = 0x2028,\n\tparagraphSeparator = 0x2029,\n\n\t// REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n\t// like an odd disparity?  (Or maybe it's completely fine for them to be different).\n\tnextLine = 0x0085,\n\n\t// Unicode 3.0 space characters\n\tspace = 0x0020,   // \" \"\n\tnonBreakingSpace = 0x00A0,   //\n\tenQuad = 0x2000,\n\temQuad = 0x2001,\n\tenSpace = 0x2002,\n\temSpace = 0x2003,\n\tthreePerEmSpace = 0x2004,\n\tfourPerEmSpace = 0x2005,\n\tsixPerEmSpace = 0x2006,\n\tfigureSpace = 0x2007,\n\tpunctuationSpace = 0x2008,\n\tthinSpace = 0x2009,\n\thairSpace = 0x200A,\n\tzeroWidthSpace = 0x200B,\n\tnarrowNoBreakSpace = 0x202F,\n\tideographicSpace = 0x3000,\n\tmathematicalSpace = 0x205F,\n\togham = 0x1680,\n\n\t_ = 0x5F,\n\t$ = 0x24,\n\n\t_0 = 0x30,\n\t_1 = 0x31,\n\t_2 = 0x32,\n\t_3 = 0x33,\n\t_4 = 0x34,\n\t_5 = 0x35,\n\t_6 = 0x36,\n\t_7 = 0x37,\n\t_8 = 0x38,\n\t_9 = 0x39,\n\n\ta = 0x61,\n\tb = 0x62,\n\tc = 0x63,\n\td = 0x64,\n\te = 0x65,\n\tf = 0x66,\n\tg = 0x67,\n\th = 0x68,\n\ti = 0x69,\n\tj = 0x6A,\n\tk = 0x6B,\n\tl = 0x6C,\n\tm = 0x6D,\n\tn = 0x6E,\n\to = 0x6F,\n\tp = 0x70,\n\tq = 0x71,\n\tr = 0x72,\n\ts = 0x73,\n\tt = 0x74,\n\tu = 0x75,\n\tv = 0x76,\n\tw = 0x77,\n\tx = 0x78,\n\ty = 0x79,\n\tz = 0x7A,\n\n\tA = 0x41,\n\tB = 0x42,\n\tC = 0x43,\n\tD = 0x44,\n\tE = 0x45,\n\tF = 0x46,\n\tG = 0x47,\n\tH = 0x48,\n\tI = 0x49,\n\tJ = 0x4A,\n\tK = 0x4B,\n\tL = 0x4C,\n\tM = 0x4D,\n\tN = 0x4E,\n\tO = 0x4F,\n\tP = 0x50,\n\tQ = 0x51,\n\tR = 0x52,\n\tS = 0x53,\n\tT = 0x54,\n\tU = 0x55,\n\tV = 0x56,\n\tW = 0x57,\n\tX = 0x58,\n\tY = 0x59,\n\tZ = 0x5a,\n\n\tampersand = 0x26,             // &\n\tasterisk = 0x2A,              // *\n\tat = 0x40,                    // @\n\tbackslash = 0x5C,             // \\\n\tbar = 0x7C,                   // |\n\tcaret = 0x5E,                 // ^\n\tcloseBrace = 0x7D,            // }\n\tcloseBracket = 0x5D,          // ]\n\tcloseParen = 0x29,            // )\n\tcolon = 0x3A,                 // :\n\tcomma = 0x2C,                 // ,\n\tdot = 0x2E,                   // .\n\tdoubleQuote = 0x22,           // \"\n\tequals = 0x3D,                // =\n\texclamation = 0x21,           // !\n\tgreaterThan = 0x3E,           // >\n\tlessThan = 0x3C,              // <\n\tminus = 0x2D,                 // -\n\topenBrace = 0x7B,             // {\n\topenBracket = 0x5B,           // [\n\topenParen = 0x28,             // (\n\tpercent = 0x25,               // %\n\tplus = 0x2B,                  // +\n\tquestion = 0x3F,              // ?\n\tsemicolon = 0x3B,             // ;\n\tsingleQuote = 0x27,           // '\n\tslash = 0x2F,                 // /\n\ttilde = 0x7E,                 // ~\n\n\tbackspace = 0x08,             // \\b\n\tformFeed = 0x0C,              // \\f\n\tbyteOrderMark = 0xFEFF,\n\ttab = 0x09,                   // \\t\n\tverticalTab = 0x0B,           // \\v\n}\n\n\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text:string, replaceCh?:string):string {\n\n\tlet _scanner = createScanner(text),\n\t\tparts: string[] = [],\n\t\tkind:SyntaxKind,\n\t\toffset = 0,\n\t\tpos:number;\n\n\tdo {\n\t\tpos = _scanner.getPosition();\n\t\tkind = _scanner.scan();\n\t\tswitch (kind) {\n\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\tcase SyntaxKind.EOF:\n\t\t\t\tif(offset !== pos) {\n\t\t\t\t\tparts.push(text.substring(offset, pos));\n\t\t\t\t}\n\t\t\t\tif(replaceCh !== void 0) {\n\t\t\t\t\tparts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n\t\t\t\t}\n\t\t\t\toffset = _scanner.getPosition();\n\t\t\t\tbreak;\n\t\t}\n\t} while(kind !== SyntaxKind.EOF);\n\n\treturn parts.join('');\n}\n\nexport interface ParseError {\n\terror: ParseErrorCode;\n}\n\nexport enum ParseErrorCode {\n\tInvalidSymbol,\n\tInvalidNumberFormat,\n\tPropertyNameExpected,\n\tValueExpected,\n\tColonExpected,\n\tCommaExpected,\n\tCloseBraceExpected,\n\tCloseBracketExpected,\n\tEndOfFileExpected\n}\n\nexport function getParseErrorMessage(errorCode: ParseErrorCode) : string {\n\tswitch (errorCode) {\n\t\tcase ParseErrorCode.InvalidSymbol: return localize('error.invalidSymbol', 'Invalid symbol');\n\t\tcase ParseErrorCode.InvalidNumberFormat: return localize('error.invalidNumberFormat', 'Invalid number format');\n\t\tcase ParseErrorCode.PropertyNameExpected: return localize('error.propertyNameExpected', 'Property name expected');\n\t\tcase ParseErrorCode.ValueExpected: return localize('error.valueExpected', 'Value expected');\n\t\tcase ParseErrorCode.ColonExpected: return localize('error.colonExpected', 'Colon expected');\n\t\tcase ParseErrorCode.CommaExpected: return localize('error.commaExpected', 'Comma expected');\n\t\tcase ParseErrorCode.CloseBraceExpected: return localize('error.closeBraceExpected', 'Closing brace expected');\n\t\tcase ParseErrorCode.CloseBracketExpected: return localize('error.closeBracketExpected', 'Closing bracket expected');\n\t\tcase ParseErrorCode.EndOfFileExpected: return localize('error.endOfFileExpected', 'End of file expected');\n\t\tdefault:\n\t\t\treturn '';\n\t}\n}\n\nexport type NodeType = \"object\" | \"array\" | \"property\" | \"string\" | \"number\" | \"boolean\" | \"null\";\n\nfunction getLiteralNodeType(value: any) : NodeType {\n\tswitch (typeof value) {\n\t\tcase 'boolean': return 'boolean';\n\t\tcase 'number': return 'number';\n\t\tcase 'string': return 'string';\n\t\tdefault: return 'null';\n\t}\n}\n\nexport interface Node {\n\ttype: NodeType;\n\tvalue?: any;\n\toffset: number;\n\tlength: number;\n\tcolumnOffset?: number;\n\tparent?: Node;\n\tchildren?: Node[];\n}\n\nexport type Segment = string | number;\nexport type JSONPath = Segment[];\n\nexport interface Location {\n\t/**\n\t * The previous property key or literal value (string, number, boolean or null) or undefined.\n\t */\n\tpreviousNode?: Node;\n\t/**\n\t * The path describing the location in the JSON document. The path consists of a sequence strings\n\t * representing an object property or numbers for array indices.\n\t */\n\tpath: JSONPath;\n\t/**\n\t * Matches the locations path against a pattern consisting of strings (for properties) and numbers (for array indices).\n\t * '*' will match a single segment, of any property name or index.\n\t * '**' will match a sequece of segments or no segment, of any property name or index.\n\t */\n\tmatches: (patterns: JSONPath) => boolean;\n\t/**\n\t * If set, the location's offset is at a property key.\n\t */\n\tisAtPropertyKey: boolean;\n}\n\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text:string, position: number) : Location {\n\tlet segments: any[] = []; // strings or numbers\n\tlet earlyReturnException = new Object();\n\tlet previousNode : Node = void 0;\n\tconst previousNodeInst : Node = {\n\t\tvalue: void 0,\n\t\toffset: void 0,\n\t\tlength: void 0,\n\t\ttype: void 0\n\t};\n\tlet isAtPropertyKey = false;\n\tfunction setPreviousNode(value: string, offset: number, length: number, type: NodeType) {\n\t\tpreviousNodeInst.value = value;\n\t\tpreviousNodeInst.offset = offset;\n\t\tpreviousNodeInst.length = length;\n\t\tpreviousNodeInst.type = type;\n\t\tpreviousNodeInst.columnOffset = void 0;\n\t\tpreviousNode = previousNodeInst;\n\t}\n\ttry {\n\n\t\tvisit(text, {\n\t\t\tonObjectBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = void 0;\n\t\t\t\tisAtPropertyKey = position > offset;\n\t\t\t\tsegments.push(''); // push a placeholder (will be replaced or removed)\n\t\t\t},\n\t\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(name, offset, length, 'property');\n\t\t\t\tsegments[segments.length - 1] = name;\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = void 0;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = void 0;\n\t\t\t\tsegments.push(0);\n\t\t\t},\n\t\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = void 0;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(value, offset, length, getLiteralNodeType(value));\n\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tif (sep === ':' && previousNode.type === 'property') {\n\t\t\t\t\tpreviousNode.columnOffset = offset;\n\t\t\t\t\tisAtPropertyKey = false;\n\t\t\t\t\tpreviousNode = void 0;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tlet last = segments[segments.length - 1];\n\t\t\t\t\tif (typeof last === 'number') {\n\t\t\t\t\t\tsegments[segments.length - 1] = last + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisAtPropertyKey = true;\n\t\t\t\t\t\tsegments[segments.length - 1] = '';\n\t\t\t\t\t}\n\t\t\t\t\tpreviousNode = void 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (e) {\n\t\tif (e !== earlyReturnException) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tif (segments[segments.length - 1] === '') {\n\t\tsegments.pop();\n\t}\n\treturn {\n\t\tpath: segments,\n\t\tpreviousNode,\n\t\tisAtPropertyKey,\n\t\tmatches: (pattern: string[]) => {\n\t\t\tlet k = 0;\n\t\t\tfor (let i = 0; k < pattern.length && i < segments.length; i++) {\n\t\t\t\tif (pattern[k] === segments[i] || pattern[k] === '*') {\n\t\t\t\t\tk++;\n\t\t\t\t} else if (pattern[k] !== '**') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn k === pattern.length;\n\t\t}\n\t};\n}\n\nexport interface ParseOptions {\n\tdisallowComments?: boolean;\n}\n\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text:string, errors: ParseError[] = [], options?: ParseOptions) : any {\n\tlet currentProperty : string = null;\n\tlet currentParent : any = [];\n\tlet previousParents : any[] = [];\n\n\tfunction onValue(value: any) {\n\t\tif (Array.isArray(currentParent)) {\n\t\t\t(<any[]> currentParent).push(value);\n\t\t} else if (currentProperty) {\n\t\t\tcurrentParent[currentProperty] = value;\n\t\t}\n\t}\n\n\tlet visitor : JSONVisitor = {\n\t\tonObjectBegin: () => {\n\t\t\tlet object = {};\n\t\t\tonValue(object);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = object;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonObjectProperty: (name: string) => {\n\t\t\tcurrentProperty = name;\n\t\t},\n\t\tonObjectEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonArrayBegin: () => {\n\t\t\tlet array = [];\n\t\t\tonValue(array);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = array;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonArrayEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonLiteralValue: onValue,\n\t\tonError:(error:ParseErrorCode) => {\n\t\t\terrors.push({error: error});\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\treturn currentParent[0];\n}\n\n\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text:string, errors: ParseError[] = [], options?: ParseOptions) : Node {\n\tlet currentParent : Node = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root\n\n\tfunction ensurePropertyComplete(endOffset:number) {\n\t\tif (currentParent.type === 'property') {\n\t\t\tcurrentParent.length = endOffset - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent;\n\t\t}\n\t}\n\n\tfunction onValue(valueNode: Node) : Node {\n\t\tcurrentParent.children.push(valueNode);\n\t\tensurePropertyComplete(valueNode.offset + valueNode.length);\n\t\treturn valueNode;\n\t}\n\n\tlet visitor : JSONVisitor = {\n\t\tonObjectBegin: (offset: number) => {\n\t\t\tcurrentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n\t\t\tcurrentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent});\n\t\t},\n\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\tensurePropertyComplete(offset);\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent;\n\t\t},\n\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent;\n\t\t},\n\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\tonValue({ type: getLiteralNodeType(value), offset, length, parent: currentParent, value });\n\t\t},\n\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\tif (currentParent.type === 'property') {\n\t\t\t\tif (sep === ':') {\n\t\t\t\t\tcurrentParent.columnOffset = offset;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tensurePropertyComplete(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonError:(error:ParseErrorCode) => {\n\t\t\terrors.push({error: error});\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\n\tlet result = currentParent.children[0];\n\tif (result) {\n\t\tdelete result.parent;\n\t}\n\treturn result;\n}\n\nexport function findNodeAtLocation(root: Node, path: JSONPath) : Node {\n\tif (!root) {\n\t\treturn void 0;\n\t}\n\tlet node = root;\n\tfor (let segment of path) {\n\t\tif (typeof segment === 'string') {\n\t\t\tif (node.type !== 'object') {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\tlet found = false;\n\t\t\tfor (let propertyNode of node.children) {\n\t\t\t\tif (propertyNode.children[0].value === segment) {\n\t\t\t\t\tnode = propertyNode.children[1];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t} else {\n\t\t\tlet index = <number> segment;\n\t\t\tif (node.type !== 'array' || index < 0 || index >= node.children.length) {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\tnode = node.children[index];\n\t\t}\n\t}\n\treturn node;\n}\n\nexport function getNodeValue(node: Node) : any {\n\tif (node.type === 'array') {\n\t\treturn node.children.map(getNodeValue);\n\t} else if (node.type === 'object') {\n\t\tlet obj = {};\n\t\tfor (let prop of node.children) {\n\t\t\tobj[prop.children[0].value] = getNodeValue(prop.children[1]);\n\t\t}\n\t\treturn obj;\n\t}\n\treturn node.value;\n}\n\n\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text:string, visitor: JSONVisitor, options?: ParseOptions) : any {\n\n\tlet _scanner = createScanner(text, false);\n\n\tfunction toNoArgVisit(visitFunction: (offset: number, length: number) => void) : () => void {\n\t\treturn visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\tfunction toOneArgVisit<T>(visitFunction: (arg: T, offset: number, length: number) => void) : (arg: T) => void {\n\t\treturn visitFunction ? (arg: T) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\n\tlet onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n\t\tonObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n\t\tonObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n\t\tonArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n\t\tonArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n\t\tonLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n\t\tonSeparator = toOneArgVisit(visitor.onSeparator),\n\t\tonError = toOneArgVisit(visitor.onError);\n\n\tlet disallowComments = options && options.disallowComments;\n\tfunction scanNext() : SyntaxKind {\n\t\twhile (true) {\n\t\t\tlet token = _scanner.scan();\n\t\t\tswitch (token) {\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidSymbol);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidSymbol);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Trivia:\n\t\t\t\tcase SyntaxKind.LineBreakTrivia:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleError(error:ParseErrorCode, skipUntilAfter: SyntaxKind[] = [], skipUntil: SyntaxKind[] = []) : void {\n\t\tonError(error);\n\t\tif (skipUntilAfter.length + skipUntil.length > 0) {\n\t\t\tlet token = _scanner.getToken();\n\t\t\twhile (token !== SyntaxKind.EOF) {\n\t\t\t\tif (skipUntilAfter.indexOf(token) !== -1) {\n\t\t\t\t\tscanNext();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (skipUntil.indexOf(token) !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttoken = scanNext();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString(isValue: boolean) : boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n\t\t\treturn false;\n\t\t}\n\t\tlet value = _scanner.getTokenValue();\n\t\tif (isValue) {\n\t\t\tonLiteralValue(value);\n\t\t} else {\n\t\t\tonObjectProperty(value);\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseLiteral() : boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.NumericLiteral:\n\t\t\t\tlet value = 0;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = JSON.parse(_scanner.getTokenValue());\n\t\t\t\t\tif (typeof value !== 'number') {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t}\n\t\t\t\tonLiteralValue(value);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tonLiteralValue(null);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tonLiteralValue(true);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tonLiteralValue(false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseProperty() : boolean {\n\t\tif (!parseString(false)) {\n\t\t\thandleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken] );\n\t\t\treturn false;\n\t\t}\n\t\tif (_scanner.getToken() === SyntaxKind.ColonToken) {\n\t\t\tonSeparator(':');\n\t\t\tscanNext(); // consume colon\n\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken] );\n\t\t\t}\n\t\t} else {\n\t\t\thandleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken] );\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseObject() : boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.OpenBraceToken) {\n\t\t\treturn false;\n\t\t}\n\t\tonObjectBegin();\n\t\tscanNext(); // consume open brace\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [] );\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], [] );\n\t\t\t}\n\t\t\tif (!parseProperty()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken] );\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonObjectEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n\t\t\thandleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close brace\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseArray() : boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.OpenBracketToken) {\n\t\t\treturn false;\n\t\t}\n\t\tonArrayBegin();\n\t\tscanNext(); // consume open bracket\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [] );\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], [] );\n\t\t\t}\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken] );\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonArrayEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n\t\t\thandleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close bracket\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseValue() : boolean {\n\t\treturn parseArray() || parseObject() || parseString(true) || parseLiteral();\n\t}\n\n\tscanNext();\n\tif (_scanner.getToken() === SyntaxKind.EOF) {\n\t\treturn true;\n\t}\n\tif (!parseValue()) {\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (_scanner.getToken() !== SyntaxKind.EOF) {\n\t\thandleError(ParseErrorCode.EndOfFileExpected, [], []);\n\t}\n\treturn true;\n}\n\nexport interface JSONVisitor {\n\t/**\n\t * Invoked when an open brace is encountered and an object is started. The offset and length represent the location of the open brace.\n\t */\n\tonObjectBegin?: (offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a property is encountered. The offset and length represent the location of the property name.\n\t */\n\tonObjectProperty?: (property: string, offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a closing brace is encountered and an object is completed. The offset and length represent the location of the closing brace.\n\t */\n\tonObjectEnd?: (offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when an open bracket is encountered. The offset and length represent the location of the open bracket.\n\t */\n\tonArrayBegin?: (offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a closing bracket is encountered. The offset and length represent the location of the closing bracket.\n\t */\n\tonArrayEnd?: (offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a literal value is encountered. The offset and length represent the location of the literal value.\n\t */\n\tonLiteralValue?: (value: any, offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a comma or colon separator is encountered. The offset and length represent the location of the separator.\n\t */\n\tonSeparator?: (charcter: string, offset:number, length:number) => void;\n\n\t/**\n\t * Invoked on an error.\n\t */\n\tonError?: (error: ParseErrorCode, offset:number, length:number) => void;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport json = require('vs/base/common/json');\nimport Modes = require('vs/editor/common/modes');\nimport jsonTokenTypes = require('vs/languages/json/common/features/jsonTokenTypes');\n\nexport function createTokenizationSupport(mode:Modes.IMode, supportComments:boolean):Modes.ITokenizationSupport {\n\treturn {\n\t\tshouldGenerateEmbeddedModels: false,\n\t\tgetInitialState: () => new JSONState(mode, null, null, false),\n\t\ttokenize: (line, state, offsetDelta?, stopAtOffset?) => tokenize(mode, supportComments, line, <JSONState> state, offsetDelta, stopAtOffset)\n\t};\n}\n\nclass JSONState implements Modes.IState {\n\n\tprivate _mode: Modes.IMode;\n\tprivate _state: Modes.IState;\n\n\tpublic scanError: json.ScanError;\n\tpublic lastWasColon: boolean;\n\n\tconstructor(mode: Modes.IMode, state: Modes.IState, scanError: json.ScanError, lastWasColon:boolean) {\n\t\tthis._mode = mode;\n\t\tthis._state = state;\n\t\tthis.scanError = scanError;\n\t\tthis.lastWasColon = lastWasColon;\n\t}\n\n\tpublic clone():JSONState {\n\t\treturn new JSONState(this._mode, this._state, this.scanError, this.lastWasColon);\n\t}\n\n\tpublic equals(other:Modes.IState):boolean {\n\t\tif(other === this) {\n\t\t\treturn true;\n\t\t}\n\t\tif(!other || !(other instanceof JSONState)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.scanError === (<JSONState> other).scanError &&\n\t\t\tthis.lastWasColon === (<JSONState> other).lastWasColon;\n\t}\n\n\tpublic getMode():Modes.IMode {\n\t\treturn this._mode;\n\t}\n\n\tpublic tokenize(stream:any):Modes.ITokenizationResult {\n\t\tthrow new Error();\n\t}\n\n\tpublic getStateData():Modes.IState {\n\t\treturn this._state;\n\t}\n\n\tpublic setStateData(state:Modes.IState):void {\n\t\tthis._state = state;\n\t}\n}\n\nfunction tokenize(mode:Modes.IMode, comments:boolean, line:string, state:JSONState, offsetDelta:number = 0, stopAtOffset?:number):Modes.ILineTokens {\n\n\t// handle multiline strings and block comments\n\tvar numberOfInsertedCharacters = 0,\n\t\tadjustOffset = false;\n\n\tswitch(state.scanError) {\n\t\tcase json.ScanError.UnexpectedEndOfString:\n\t\t\tline = '\"' + line;\n\t\t\tnumberOfInsertedCharacters = 1;\n\t\t\tbreak;\n\t\tcase json.ScanError.UnexpectedEndOfComment:\n\t\t\tline = '/*' + line;\n\t\t\tnumberOfInsertedCharacters = 2;\n\t\t\tbreak;\n\t}\n\n\tvar scanner = json.createScanner(line),\n\t\tkind: json.SyntaxKind,\n\t\tret:Modes.ILineTokens,\n\t\tlastWasColon = state.lastWasColon;\n\n\tret = {\n\t\ttokens: <Modes.IToken[]>[],\n\t\tactualStopOffset: line.length,\n\t\tendState: state.clone(),\n\t\tmodeTransitions: [{ startIndex: 0, mode: mode }],\n\t};\n\n\twhile(true) {\n\n\t\tvar offset = offsetDelta + scanner.getPosition(),\n\t\t\ttype = '';\n\n\t\tkind = scanner.scan();\n\t\tif(kind === json.SyntaxKind.EOF) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Check that the scanner has advanced\n\t\tif (offset === offsetDelta + scanner.getPosition()) {\n\t\t\tthrow new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\n\t\t}\n\n\t\t// In case we inserted /* or \" character, we need to\n\t\t// adjust the offset of all tokens (except the first)\n\t\tif(adjustOffset) {\n\t\t\toffset -= numberOfInsertedCharacters;\n\t\t}\n\t\tadjustOffset = numberOfInsertedCharacters > 0;\n\n\n\t\t// brackets and type\n\t\tswitch(kind) {\n\t\t\tcase json.SyntaxKind.OpenBraceToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_OBJECT;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.CloseBraceToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_OBJECT;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.OpenBracketToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_ARRAY;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.CloseBracketToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_ARRAY;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.ColonToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_COLON;\n\t\t\t\tlastWasColon = true;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.CommaToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_COMMA;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.TrueKeyword:\n\t\t\tcase json.SyntaxKind.FalseKeyword:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_VALUE_BOOLEAN;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.NullKeyword:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_VALUE_NULL;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.StringLiteral:\n\t\t\t\ttype = lastWasColon ? jsonTokenTypes.TOKEN_VALUE_STRING : jsonTokenTypes.TOKEN_PROPERTY_NAME;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.NumericLiteral:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_VALUE_NUMBER;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// comments, iff enabled\n\t\tif(comments) {\n\t\t\tswitch (kind) {\n\t\t\t\tcase json.SyntaxKind.LineCommentTrivia:\n\t\t\t\t\ttype = jsonTokenTypes.TOKEN_COMMENT_LINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase json.SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\ttype = jsonTokenTypes.TOKEN_COMMENT_BLOCK;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tret.endState = new JSONState(state.getMode(), state.getStateData(), scanner.getTokenError(), lastWasColon);\n\t\tret.tokens.push({\n\t\t\tstartIndex: offset,\n\t\t\ttype: type\n\t\t});\n\t}\n\n\treturn ret;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport editorCommon = require('vs/editor/common/editorCommon');\nimport modes = require('vs/editor/common/modes');\nimport URI from 'vs/base/common/uri';\nimport WinJS = require('vs/base/common/winjs.base');\nimport Platform = require('vs/platform/platform');\nimport jsonWorker = require('vs/languages/json/common/jsonWorker');\nimport tokenization = require('vs/languages/json/common/features/tokenization');\nimport {AbstractMode, createWordRegExp, ModeWorkerManager} from 'vs/editor/common/modes/abstractMode';\nimport {OneWorkerAttr, AllWorkersAttr} from 'vs/platform/thread/common/threadService';\nimport {IThreadService, ThreadAffinity} from 'vs/platform/thread/common/thread';\nimport {IJSONContributionRegistry, Extensions, ISchemaContributions} from 'vs/platform/jsonschemas/common/jsonContributionRegistry';\nimport {IInstantiationService} from 'vs/platform/instantiation/common/instantiation';\nimport {LanguageConfigurationRegistry, LanguageConfiguration} from 'vs/editor/common/modes/languageConfigurationRegistry';\nimport {wireCancellationToken} from 'vs/base/common/async';\n\nexport class JSONMode extends AbstractMode {\n\n\tpublic static LANG_CONFIG:LanguageConfiguration = {\n\t\twordPattern: createWordRegExp('.-'),\n\n\t\tcomments: {\n\t\t\tlineComment: '//',\n\t\t\tblockComment: ['/*', '*/']\n\t\t},\n\n\t\tbrackets: [\n\t\t\t['{', '}'],\n\t\t\t['[', ']']\n\t\t],\n\n\t\tautoClosingPairs: [\n\t\t\t{ open: '{', close: '}', notIn: ['string'] },\n\t\t\t{ open: '[', close: ']', notIn: ['string'] },\n\t\t\t{ open: '\"', close: '\"', notIn: ['string'] }\n\t\t]\n\t};\n\n\tpublic tokenizationSupport: modes.ITokenizationSupport;\n\tpublic configSupport:modes.IConfigurationSupport;\n\tpublic inplaceReplaceSupport:modes.IInplaceReplaceSupport;\n\n\tprivate _modeWorkerManager: ModeWorkerManager<jsonWorker.JSONWorker>;\n\tprivate _threadService:IThreadService;\n\n\tconstructor(\n\t\tdescriptor:modes.IModeDescriptor,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@IThreadService threadService: IThreadService\n\t) {\n\t\tsuper(descriptor.id);\n\t\tthis._modeWorkerManager = new ModeWorkerManager<jsonWorker.JSONWorker>(descriptor, 'vs/languages/json/common/jsonWorker', 'JSONWorker', null, instantiationService);\n\t\tthis._threadService = threadService;\n\n\t\tthis.tokenizationSupport = tokenization.createTokenizationSupport(this, true);\n\n\t\tLanguageConfigurationRegistry.register(this.getId(), JSONMode.LANG_CONFIG);\n\n\t\tmodes.HoverProviderRegistry.register(this.getId(), {\n\t\t\tprovideHover: (model, position, token): Thenable<modes.Hover> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideHover(model.uri, position));\n\t\t\t}\n\t\t}, true);\n\n\t\tthis.inplaceReplaceSupport = this;\n\n\t\tthis.configSupport = this;\n\n\t\t// Initialize Outline support\n\t\tmodes.DocumentSymbolProviderRegistry.register(this.getId(), {\n\t\t\tprovideDocumentSymbols: (model, token): Thenable<modes.SymbolInformation[]> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideDocumentSymbols(model.uri));\n\t\t\t}\n\t\t}, true);\n\n\t\tmodes.DocumentFormattingEditProviderRegistry.register(this.getId(), {\n\t\t\tprovideDocumentFormattingEdits: (model, options, token): Thenable<editorCommon.ISingleEditOperation[]> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideDocumentFormattingEdits(model.uri, options));\n\t\t\t}\n\t\t}, true);\n\n\t\tmodes.DocumentRangeFormattingEditProviderRegistry.register(this.getId(), {\n\t\t\tprovideDocumentRangeFormattingEdits: (model, range, options, token): Thenable<editorCommon.ISingleEditOperation[]> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideDocumentRangeFormattingEdits(model.uri, range, options));\n\t\t\t}\n\t\t}, true);\n\n\t\tmodes.SuggestRegistry.register(this.getId(), {\n\t\t\ttriggerCharacters: [],\n\t\t\tshouldAutotriggerSuggest: true,\n\t\t\tprovideCompletionItems: (model, position, token): Thenable<modes.ISuggestResult[]> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideCompletionItems(model.uri, position));\n\t\t\t}\n\t\t}, true);\n\t}\n\n\tpublic creationDone(): void {\n\t\tif (this._threadService.isInMainThread) {\n\t\t\t// Pick a worker to do validation\n\t\t\tthis._pickAWorkerToValidate();\n\n\t\t\t// Configure all workers\n\t\t\tthis._configureWorkerSchemas(this.getSchemaConfiguration());\n\t\t\tvar contributionRegistry = <IJSONContributionRegistry> Platform.Registry.as(Extensions.JSONContribution);\n\t\t\tcontributionRegistry.addRegistryChangedListener(e => {\n\t\t\t\tthis._configureWorkerSchemas(this.getSchemaConfiguration());\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _worker<T>(runner:(worker:jsonWorker.JSONWorker)=>WinJS.TPromise<T>): WinJS.TPromise<T> {\n\t\treturn this._modeWorkerManager.worker(runner);\n\t}\n\n\tprivate getSchemaConfiguration() : ISchemaContributions {\n\t\tvar contributionRegistry = <IJSONContributionRegistry> Platform.Registry.as(Extensions.JSONContribution);\n\t\treturn contributionRegistry.getSchemaContributions();\n\t}\n\n\tpublic configure(options:any): WinJS.TPromise<void> {\n\t\tif (this._threadService.isInMainThread) {\n\t\t\treturn this._configureWorkers(options);\n\t\t} else {\n\t\t\treturn this._worker((w) => w._doConfigure(options));\n\t\t}\n\t}\n\n\tstatic $_configureWorkers = AllWorkersAttr(JSONMode, JSONMode.prototype._configureWorkers);\n\tprivate _configureWorkers(options:any): WinJS.TPromise<void> {\n\t\treturn this._worker((w) => w._doConfigure(options));\n\t}\n\n\tstatic $_configureWorkerSchemas = AllWorkersAttr(JSONMode, JSONMode.prototype._configureWorkerSchemas);\n\tprivate _configureWorkerSchemas(data:ISchemaContributions): WinJS.TPromise<boolean> {\n\t\treturn this._worker((w) => w.setSchemaContributions(data));\n\t}\n\n\tstatic $_pickAWorkerToValidate = OneWorkerAttr(JSONMode, JSONMode.prototype._pickAWorkerToValidate, ThreadAffinity.Group1);\n\tprivate _pickAWorkerToValidate(): WinJS.TPromise<void> {\n\t\treturn this._worker((w) => w.enableValidator());\n\t}\n\n\tstatic $navigateValueSet = OneWorkerAttr(JSONMode, JSONMode.prototype.navigateValueSet);\n\tpublic navigateValueSet(resource:URI, position:editorCommon.IRange, up:boolean):WinJS.TPromise<modes.IInplaceReplaceSupportResult> {\n\t\treturn this._worker((w) => w.navigateValueSet(resource, position, up));\n\t}\n\n\tstatic $_provideCompletionItems = OneWorkerAttr(JSONMode, JSONMode.prototype._provideCompletionItems);\n\tprivate _provideCompletionItems(resource:URI, position:editorCommon.IPosition):WinJS.TPromise<modes.ISuggestResult[]> {\n\t\treturn this._worker((w) => w.provideCompletionItems(resource, position));\n\t}\n\n\tstatic $_provideHover = OneWorkerAttr(JSONMode, JSONMode.prototype._provideHover);\n\tprivate _provideHover(resource:URI, position:editorCommon.IPosition): WinJS.TPromise<modes.Hover> {\n\t\treturn this._worker((w) => w.provideHover(resource, position));\n\t}\n\n\tstatic $_provideDocumentSymbols = OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentSymbols);\n\tprivate _provideDocumentSymbols(resource:URI):WinJS.TPromise<modes.SymbolInformation[]> {\n\t\treturn this._worker((w) => w.provideDocumentSymbols(resource));\n\t}\n\n\tstatic $_provideDocumentFormattingEdits = OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentFormattingEdits);\n\tpublic _provideDocumentFormattingEdits(resource:URI, options:modes.FormattingOptions):WinJS.TPromise<editorCommon.ISingleEditOperation[]> {\n\t\treturn this._worker((w) => w.format(resource, null, options));\n\t}\n\n\tstatic $_provideDocumentRangeFormattingEdits = OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentRangeFormattingEdits);\n\tpublic _provideDocumentRangeFormattingEdits(resource:URI, range:editorCommon.IRange, options:modes.FormattingOptions):WinJS.TPromise<editorCommon.ISingleEditOperation[]> {\n\t\treturn this._worker((w) => w.format(resource, range, options));\n\t}\n}"]}